This is kawa.info, produced by makeinfo version 4.13 from kawa.texi.

START-INFO-DIR-ENTRY
* kawa: (kawa).         The Kawa language framework
END-INFO-DIR-ENTRY


File: kawa.info,  Node: Top,  Next: Installation,  Prev: (dir),  Up: (dir)

The Kawa language framework
***************************

Kawa is:
   • A framework written in Java for implementing high-level and dynamic
     languages, compiling them into Java bytecodes.

   • An implementation of Scheme (http://www.schemers.org/), which is in
     the Lisp family of programming languages.  Kawa is a featureful
     dialect in its own right, and additionally provides very useful
     integration with Java.  It can be used as a “scripting language”,
     but includes a compiler and all the benefits of a “real”
     programming language, including optional static typing.

   • Implementations of other programming languages, including XQuery
     (Qexo) (../qexo/index.html) and Emacs Lisp (JEmacs)
     (http://JEmacs.sourceforge.net/).

   This documents version 1.11, updated 10 November 2010.  See the
summary of recent changes (http://www.gnu.org/software/kawa/news.html).

   The Kawa home page (which is currently just an on-line version of
this document) is `http://www.gnu.org/software/kawa/'.

   For lots of Scheme resources, see www.schemers.org
(http://www.schemers.org/), including an online copy of the R6RS
standard (http://www.schemers.org/Documents/Standards/).  A nice quick
introduction to Scheme can be found in Greg Badros's lecture notes
(http://www.cs.washington.edu/education/courses/341/99su/lectures/scheme/).
A more in-depth tutorial which also discusses Scheme implementation is
Paul Wilson's "An Introduction to Scheme and its Implementation"
(ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html).

   For a technical overview of Kawa, see these
`http://www.gnu.org/software/kawa/internals/index.html'.  Javadoc
generated documentation of the Kawa classes
(http://www.gnu.org/software/kawa/api/) is also available.  The packages
`gnu.bytecode'
(http://www.gnu.org/software/kawa/api/gnu/bytecode/package-summary.html),
`gnu.math'
(http://www.gnu.org/software/kawa/api/gnu/math/package-summary.html),
`gnu.lists'
(http://www.gnu.org/software/kawa/api/gnu/lists/package-summary.html),
`gnu.xml'
(http://www.gnu.org/software/kawa/api/gnu/xml/package-summary.html),
`gnu.expr'
(http://www.gnu.org/software/kawa/api/gnu/expr/package-summary.html),
`gnu.mapping'
(http://www.gnu.org/software/kawa/api/gnu/mapping/package-summary.html),
and `gnu.text'
(http://www.gnu.org/software/kawa/api/gnu/text/package-summary.html),
are used by Kawa, and distributed with it, but may be independently
useful.

   For copyright information on the software and documentation, see
*note License::.

   The author of Kawa is Per Bothner (http://www.bothner.com/per/)
<per@bothner.com>.  Thanks to Brainfood (http://www.brainfood.com/) and
Merced Systems (http://www.mercedsystems.com/) for support in developing
Kawa.  Kawa is a re-write of Kawa 0.2, which was written by R. Alexander
Milowski <alex@milowski.com>.

   This package has nothing to do with the defunct Kawa commercial Java
IDE.

* Menu:

* Installation::         Building and installing Kawa
* Running::              Invoking, Running, and Using Kawa
* Features::             Summary of Kawa Scheme Features
* Syntax::
* Multiple values::
* Symbols and namespaces::
* Procedures::
* Numbers::              Quantities and Numbers
* Characters and text::
* Data structures::
* Exceptions::           Exception handling
* Eval and Environments::
* Debugging::
* Threads::
* Processes::
* Miscellaneous::
* Input-Output::         Input, output, and file handling
* Types::
* Objects Classes and Modules::
* XML tools::            XML, HTML, and the web
* Low-level functions::  Deprecated low-level functions
* FAQs:: Frequently Asked Questions
* Community::
* License::
* Overall Index::	 Index of functions, macros, concepts, and more.


File: kawa.info,  Node: Installation,  Next: Running,  Prev: Top,  Up: Top

1 Getting and installing Kawa
*****************************

* Menu:

* Getting Kawa::
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution


File: kawa.info,  Node: Getting Kawa,  Next: Running Java,  Up: Installation

1.1 Getting Kawa
================

You can compile Kawa from the source distribution.  Alternatively, you
can install the pre-compiled binary distribution.

   You can get Kawa sources and binaries from the Kawa ftp site
`ftp://ftp.gnu.org/pub/gnu/kawa/', or from a mirror site
(http://www.gnu.org/order/ftp.html).

   The latest release of the Kawa source code is
`ftp://ftp.gnu.org/pub/gnu/kawa/kawa-1.11.tar.gz'.  (To unpack `.tar.gz'
files Windows users can use 7-Zip (http://www.7-zip.org/), which is Free
Software.)

   A ready-to-run `.jar' archive of the pre-compiled classes is in
`ftp://ftp.gnu.org/pub/gnu/kawa/kawa-1.11.jar'.

1.1.1 Getting the development sources using SVN
-----------------------------------------------

The Kawa sources are managed using a Subversion (svn)
(http://subversion.tigris.org/) repository.  If you want the very latest
version grab an svn client
(http://subversion.tigris.org/project_packages.html), and then check out
the source using this command:
     svn -q checkout svn://sourceware.org/svn/kawa/trunk kawa

   If you're beyond a firewall or HTTP proxy, you can edit
`http-proxy-host' and `http-proxy-port' in `~/.subversion/servers' as
described here (http://subversion.tigris.org/faq.html#proxy),.  and then
do:
     svn -q checkout http://sourceware.org/svn/kawa/trunk kawa

   Once you have it checked out, you can keep it up-to-date with `svn
update'.

   You can also browse the svn archive
(http://sourceware.org/viewvc/kawa/) via viewvc.


File: kawa.info,  Node: Running Java,  Next: Binary distribution,  Prev: Getting Kawa,  Up: Installation

1.2 Getting and running Java
============================

Before installing Kawa, you will need a working Java system.  Kawa has
been reported to work with JDK from 1.1 through 1.6, Kaffe, Symantec
Cafe, J++, and GCJ.  The released Kawa jar file assumes JDK 1.5 or
equivalent functionality.  If those features are missing, you may need
to build Kawa from source.

   The discussion below assumes you are using the Java Developer's Kit
(JDK) from Sun.  You can download free copies of JDK 1.6
(http://java.sun.com/javase/downloads/index.jsp) for various platforms.

   If you want to run Kawa on a Macintosh, see
`http://rdsathene.org/scheme/mackawa.html'.

   The program `java' is the Java interpreter.  The program `javac' is
the Java compiler, and is needed if you want to compile the source
release yourself.  Both programs must be in your `PATH'.  If you have
the JDK in directory `$JDK', and you are using a Bourne-shell compatible
shell (/bin/sh, ksh, bash, and some others) you can set `PATH' thus:
     PATH=$JDK/bin:$PATH
     export PATH


File: kawa.info,  Node: Binary distribution,  Next: Source distribution,  Prev: Running Java,  Up: Installation

1.3 Installing and using the binary distribution
================================================

The binary release includes only the binary compiled `.class' versions
of the same `.java' source files in the source release.  It does not
include any documentation, so you probably want the source release in
addition to the binary release.  The purpose of the binary release is
just to save you the time and trouble of compiling the sources.

   The binary release requires Java 5 (JDK 1.5) or later.  It does
include support for certain Java 6 features (`HttpServer',
`javax.script', and Unicode normalization), but these feature only work
if you use Java 6, not Java 5.  If you have an older Java
implementation, or build for a mobile environment like Android, or
optimize for Java 6, then you will need to get the source distribution.

   The binary release comes as a `.jar' archive `kawa-1.11.jar'.  Copy
this archive to some suitable location, such as
`/usr/local/lib/kawa.jar'.

   Then, before you can actually run Kawa, you need to set `CLASSPATH'
so it includes the Kawa archive.  On Unix, using a Bourne-style shell:
     CLASSPATH=/usr/local/lib/kawa.jar
     export CLASSPATH

   On Windows you need to set `classpath' in a DOS console.  For
example:
     set classpath=\kawa\kawa-1.11.jar

   Then to run Kawa do:
     java kawa.repl

   To run Kawa in a fresh window, you can do:
     java kawa.repl -w


File: kawa.info,  Node: Source distribution,  Prev: Binary distribution,  Up: Installation

1.4 Installing and using the source distribution
================================================

The Kawa release normally comes as a gzip-compressed tar file named
`kawa-1.11.tar.gz'.  Two methods are supporting for compiling the Kawa
sources; choose whichever is most convenient for you.

   One method uses the traditional GNU `configure' script, followed by
running `make'.  This works well on Unix-like systems, such as
GNU/Linux.  It does not work well under Microsoft Windows. (Even when
using the CygWin Unix-emulation package there are some problems with
file paths.)

   The other method uses the `ant' command, a Java-based build system
released by Apache's Jakarta project.  This uses an `build.xml' file in
place of `Makefile's, and works on non-Unix systems such as Microsoft
Windows.  However, the `ant' method does not support all the features of
the `configure'+`make' method.

1.4.1 Build Kawa using `configure' and `make'
---------------------------------------------

In your build directory do:
     tar xzf kawa-1.11.tar.gz
     cd kawa-1.11

   Then you must configure the sources.  This you can do the same way
you configure most other GNU software.  Normally you can just run the
configure script with no arguments:

     ./configure

   This will specify that a later `make install' will install the
compiled `.class' files into `/usr/local/share/java'.  If you want them
to be installed someplace else, such as `$PREFIX/share/java', then
specify that when you run configure:
     ./configure --prefix $PREFIX

   If you have the GNU `readline' library installed, you might try
adding the `--enable-kawa-frontend' flag.  This will build the `kawa'
front-end program, which provides input-line editing and an input
history.  You can get `readline' from archives of GNU programs,
including `ftp://www.gnu.org/'.

   If you have Swing installed, and want to use JEmacs (Emacs in Java),
also pass the `--with-swing' flag to `configure'.

   If you have installed Kawa before, make sure your `CLASSPATH' does
not include old versions of Kawa, or other classes that may conflict
with the new ones.

   As-distributed, the Kawa source code requires Java 6.  If you only
have Java 5, use the `--with-have-source' option:
     ./configure --with-java-source=5

   If you want to add support for certain Java 6 features, but produce a
`.jar' file that will execute under Java 5 do:
     ./configure --with-java-source=6compat5
   Note this requires that you build Kawa with Java 6.

   In theory Kawa supports older versions of Java (such as JDK 1.4 or
even 1.1), though this has not been tested in a while.  You use the
appropriate `--with-java-source' option, but you still need a Java 5 or
later version of `javac' to build Kawa.  You then need to use a tool
like Retroweaver (http://retroweaver.sourceforge.net/) on the Kawa
`.jar' to fix up Java 5 dependencies.  Contact the Kawa author if you
want to be a tester for this.

   Then you need to compile all the .java source files.  Just run make:
     make
   This assumes that `java' and `javac' are the java interpreter and
compiler, respectively.  For example, if you are using the Kaffe Java
interpreter, you need to instead say:
     make JAVA=kaffe

   It has been reported that parallel make doesn't work, so don't use
the `-j2' or above options.

   You can now test the system by running Kawa in place:
     java kawa.repl

   or you can run the test suite:
     make check

   or you can install the compiled files:
     make install

   This will install your classes into `$PREFIX/share/java' (and its
sub-directories).  Here `$PREFIX' is the directory you specified to
configure with the `--prefix' option, or `/usr/local' if you did not
specify a `--prefix' option.

   To use the installed files, you need to set `CLASSPATH' so that
`$PREFIX/share/java/kawa.jar' is in the path:
     CLASSPATH=$PREFIX/share/java/kawa.jar
     export CLASSPATH
   This is done automatically if you use the `kawa' script.

1.4.2 Build Kawa using `ant'
----------------------------

Kawa now includes an Ant buildfile (`build.xml').  Ant
(http://ant.apache.org) is a part of the Apache Jakarta project.  If you
don't hava Ant installed, get it from
`http://ant.apache.org/bindownload.cgi'.  The build is entirely Java
based and works equally well on *nix, Windows, and presumably most any
other operating system.

   Once Ant has been installed and configured (you may need to set the
`JAVA_HOME', and `ANT_HOME' environment variables), you should be able
to change to the directory containing the `build.xml' file, and invoke
the `ant' command.  With the default settings, a successful build will
result in a `kawa-1.11.jar' in the current directory.

   There are a few Ant "targets" of interest (they can be supplied on
the Ant command line):

`all'
     This is the default, it does `classes' and `jar'.

`classes'
     Compiles all the files into `*.class' files into the directory
     specified by the `build.dir' property.

`jar'
     Builds a jar into into the directory specified by the `dist.dir'
     property.

`runw'
     Run Kawa in a GUI window.

`clean'
     Deletes all files generated by the build, including the jar.

   There is not yet a `test' target for running the testsuite.

   The are various "properties" that control what `ant' does.  You can
override the on the command line or by editing the `build.properties'
file in the same directory as `build.xml'.  For example the `build.dir'
directory tells `ant' where to build temporary files, and where to leave
the resulting `.jar' file.  For example, to leave the generated files in
the sub-directory named `BUILD' do:
     ant -Dbuild.dir=BUILD
   A sample `build.properties' is provided and it contains comments
explaining many of the options.

   Here are a few general properties that help to customize your build:
`build.dir'
     Path to put the temporary files used for building.

`dist.dir'
     Path to put the resulting jar file.

`version.local'
     A suffix to add to the version label for your customized version.

`debug'
     Whether (true/false) the Javac "-g" option is enabled.

`optimize'
     Whether (true/false) the Javac "-O" option is enabled.

   Here are some Kawa-specific ones (all `true'/`false'):
`with-collections', `with-references', `with-awt', `with-swing',
`enable-jemacs', and `enable-servlet'> See the sample `build.properties'
for more information on these.

   If you change any of the build properties, you will generally want to
do an `ant clean' before building again as the build is often not able
to notice that kind of change.  In the case of changing a directory
path, you would want to do the `clean' before changing the path.

   A special note for NetBeans users: For some reason the build-tools
target which compiles an Ant task won't compile with the classpath
provided by NetBeans.  You may do `ant build-tools' from the command
line outside of NetBeans, in which case you will not want to use the
`clean' target as that will delete the tool files as well.  You can use
the `clean-build' and/or `clean-dist' targets as appropriate.
Alternatively you can add `ant.jar' to the `build-tools' classpath by
copying or linking it into a `lib/ext' directory in Kawa's source
directory (the one containing the `build.xml' file).

1.4.3 Compiling Kawa to native code with GCJ
--------------------------------------------

The GNU Compiler for the Java(tm) Programming Language (GCJ
(http://gcc.gnu.org/java/)) is part of the GNU Compiler Collection (GCC
(http://gcc.gnu.org/)).  It can compile Java source or bytecode files
into native code on supported systems.  Version 4.1 or later of GCC is
recommended, and only Intel x86-based Linux/GNU system have been tested
with Kawa.

   First, get and install GCC.  Set `PREFIX' to where you want to
install GCJ, and configure it with these options:
     ./configure --enable-threads --enable-languages=c++,java --prefix $PREFIX
     make bootstrap
     make install
   Make sure `gcj' is in your path and refers to the newly-installed
version, and if needed, set `LD_LIBRARY_PATH' to point to the directory
where `libgcj.so' was installed:
     PATH=$PREFIX/bin:$PATH
     LD_LIBRARY_PATH=$PREFIX/lib
     export LD_LIBRARY_PATH

   To build Kawa, you need to specify `--with-gcj' to `configure' which
tells it to use GCJ.
     ./configure --with-gcj --prefix $PREFIX
   Then as before:
     make
     make install

   Alternatively, you can use configure option `--with-gcj-dbtool'.
This allows gcj to automatically find the kawa shared libraries from the
`.jar' file.

1.4.4 Building Kawa under MS-Windows
------------------------------------

Using the `ant' method is recommended for building Kawa under Microsoft
Windows.  You may get an error message "`Out of environment space'."
See `http://support.microsoft.com/support/kb/articles/Q230/2/05.ASP' for
a solution.  Alternatively you can run the class
`org.apache.tools.ant.Main' directly from the Ant jar.

   The Kawa `configure' and `make' process assumes a Unix-like
environment.  If you want to build Kawa from source under Windows, you
could use a Unix empulation package, such as the free Cygwin
(http://sourceware.org/cygwin/).  However, there are some problems with
filenames that make this more complicated than it should be.  It should
be possible to build Kawa under Cygwin using `gcj' as descibed above.


File: kawa.info,  Node: Running,  Next: Features,  Prev: Installation,  Up: Top

2 How to start up and run Kawa
******************************

The easiest way to start up Kawa is to run the `kawa' program.  This
finds your java interpreter, and sets up `CLASSPATH' correctly.  If you
have installed Kawa such `$PREFIX/bin' is in your `$PATH', just do:
     kawa
   However, `kawa' only works if you have a Unix-like environment.  On
some platforms, `kawa' is a program that uses the GNU `readline' library
to provide input line editing.

   To run Kawa manually, you must start a Java interpreter.  How you do
this depends on the Java interpreter.  For Sun's JDK s and some other
implementations, you must have the Java interpret (usually named `java')
in your `PATH'.  You must also make sure that the `kawa/repl.class'
file, the rest of the Kawa packages, and the standard Java packages can
be found by searching CLASSPATH.  *Note Running Java::.

   Then you do:
     java kawa.repl

   In either case, you will then get the `#|kawa:1|#' prompt, which
means you are in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the result (if
there is a non-"void" result).

* Menu:

* Options::      Command-line arguments
* Scripts::      Running Command Scripts
* New-Window::   Running a Command Interpreter in a new Window
* Exiting::      Exiting Kawa
* Compiling::    Compiling to byte-code or an executable


File: kawa.info,  Node: Options,  Next: Scripts,  Prev: Running,  Up: Running

2.1 Command-line arguments
==========================

You can pass various flags to Kawa, for example:
     kawa -e '(display (+ 12 4))(newline)'
   or:
     java kawa.repl -e '(display (+ 12 4))(newline)'
   Either causes Kawa to print `16', and then exit.

   At startup, Kawa executes an init file from the user's home
directory.  The init file is named `.kawarc.scm' on Unix-like systems
(those for which the file separator is `'/''), and `kawarc.scm' on other
systems.  This is done before the read-eval-print loop or before the
first `-f' or `-c' argument.  (It is not run for a `-e' command, to
allow you to set options to override the defaults.)

   If there are further command-line arguments after the options have
been processed, then the first remaining argument names a file that is
read and evaluated.  If there is no such argument, then Kawa enters an
interactive read-eval-print loop, but only if none of the `-c', `-e',
`-f', `-s', `-C', or `--' options were specified.

2.1.1 General options
---------------------

`-e expr'
     Kawa evaluates expr, which contains one or more Scheme expressions.
     Does not cause the `~/.kawarc.scm' init file to be run.

`-c expr'
     Same as `-e expr', except that it does cause the `~/.kawarc.scm'
     init file to be run.

`-f filename-or-url'
     Kawa reads and evaluates expressions from the file named by
     filename-or-url.  If the latter is `-', standard input is read
     (with no prompting).  Otherwise, it is equivalent to evaluating
     `(load "filename-or-url")'.  The filename-or-url is interpreted as
     a URL if it is absolute - it starts with a "URI scheme" like
     `http:'.

`-s'
`--'
     The global variable `command-line-arguments' is set to the
     remaining arguments (if any), and an interactive read-eval-print
     loop is started.  This uses the same "console" as where you started
     up Kawa; use `-w' to get a new window.

`--script filename-or-url'
`--scriptN filename-or-url'
     The global variable `command-line-arguments' is set to the
     remaining arguments (if any).  Kawa reads and evaluates expressions
     from the file named by filename-or-url.  If `script' is followed by
     an integer N, then N lines are skipped first.

     Skipping some initial lines is useful if you want to have a
     non-Kawa preamble before the actual Kawa code.  One use for this is
     for Kawa shell scripts (*note Scripts::).

`-w'
     Creates a new top-level window, and runs an interactive
     read-eval-print in the new window.  See *note New-Window::.  Same
     as `-e (scheme-window #t)'.  You can specify multiple `-w' options,
     and also use `-s'.

`--help'
     Prints out some help.

`--version'
     Prints out the Kawa version number, and then exits.

`--server portnum'
     Start a server listening from connections on the specified portnum.
     Each connection using the Telnet protocol causes a new
     read-eval-print-loop to started.  This option allows you to connect
     using any Telnet client program to a remote "Kawa server".

2.1.2 Options for language selection
------------------------------------

`--scheme'
     Set the default language to Scheme.  (This is the default unless
     you select another language, or you name a file with a known
     extension on the command-line.)

`--elisp'
`--emacs'
`--emacs-lisp'
     Set the default language to Emacs Lisp.  (The implementation is
     quite incomplete.)

`--lisp'
`--clisp'
`--clisp'
`--commonlisp'
`--common-lisp'
     Set the default language to CommonLisp.  (The implementation is
     _very_ incomplete.)

`--krl'
     Set the default language to KRL.  See *note KRL::.

`--brl'
     Set the default language to KRL, in BRL-compatibility mode.  See
     *note KRL::.

`--xquery'
     Set the default language to the draft XML Query language.  See the
     Kawa-XQuery page (http://www.gnu.org/software/qexo/) for more
     information.

`--xslt'
     Set the default language to XSLT (XML Stylesheet Language
     Transformations).  (The implementation is _very_ incomplete.)  See
     the Kawa-XSLT page (http://www.gnu.org/software/qexo/xslt.html) for
     more information.

`--pedantic'
     Try to follow the approprate language specification to the letter,
     even in corner cases, and even if it means giving up some Kawa
     convenience features.  This flags so far only affects the XQuery
     parser, but that will hopefully change.

2.1.3 Options for setting variables
-----------------------------------

`name=value'
     Set the global variable with the specified name to the given value.
     The type of the value is currently unspecified; the plan is for it
     to be like XQuery's "untyped atomic" which can be coerced as
     needed.

`{namespace-uri}local-name=value'
     Set the global variable with the specified namespace uri and
     namespace-local name to the given value.

   These options are processed when invoking the `kawa' application
(i.e. the `kawa.repl' application).  If you want a Kawa application
compiled with `--main' to process these these assignments, call the
`process-command-line-assignments' utility function.

2.1.4 Options for controlling output formatting
-----------------------------------------------

`--output-format format'
`--format format'
     Change the default output format to that specified by format.  See
     *note Named output formats:: for more information and a list.

`out:base=integer'
     The number base (radix) to use by default when printing rational
     numbers.  Must be an integer between 2 and 36, and the default is
     of course 10.  For example the option `out:base=16' produces
     hexadecimal output.  Equivalent to setting the `*print-base*'
     variable.

`out:radix=no|yes'
     If true, prints an indicator of the radix used when printing
     rational numbers.  The default is `no'.  Equivalent to setting the
     `*print-radix*' variable.

`out:doctype-system=system-identifier'
     If `out:doctype-system' is specified then a `DOCTYPE' declaration
     is written before writing a top-level XML element, using the
     specified system-identifier.

`out:doctype-public=public-identifier'
     Ignored unless  `out:doctype-system' is also specified, in which
     case the public-identifier is written as the public identifiers of
     the `DOCTYPE' declaration.

`out:xml-indent=kind'
     Controls whether extra line breaks and indentation are added when
     printing XML.  If kind is `always' or `yes' then newlines and
     appropriate indentation are added before and after each element.
     If kind is `pretty' then the pretty-printer is used to only add new
     lines when an element otherwise won't fit on a single line.  If
     kind is `no' (the default) then no extra line breaks or indentation
     are added.

`out:line-length=columns'
`out:right-margin=columns'
     Specifies the maximum number of number of columns in a line when
     the pretty-printer decides where to break a line.  (The two options
     are equivalent.)

2.1.5 Options for compiling and optimizing
------------------------------------------

The following options control which calling conventions are used:
`--full-tailcalls'
     Use a calling convention that supports proper tail recursion.

`--no-full-tailcalls'
     Use a calling convention that does not support proper tail
     recursion.  Self-tail-recursion (i.e. a recursive call to the
     current function) is still implemented correctly, assuming that the
     called function is known at compile time.

`--no-inline'
     Disable inlining of known functions and methods.  The generated
     code runs slower, but you can more reliably trace procedures.
     Normally Kawa will assume that a procedure `fn' declared using a
     `(define (fn args) body)' form is constant, assuming it isn't
     modified in the current module.  However, it is possible some other
     module might modify the binding of `fn'.  You can use the
     `--no-inline' to disable the assumption that `fn' is constant.

   The default is currently `--no-full-tailcalls' because it is usually
faster.  It is also closer to the Java call model, so may be better for
people primarily interested in using Kawa for scripting Java systems.

   Both calling conventions can co-exist:  Code compiled with
`--full-tailcalls' can call code compiled with `--no-full-tailcalls' and
vice versa.

`--target version'
     The version can be a JDK or Java specification version: `1.1',
     `1.2', `1.3', `1.4', `5', `6', or `7'.  The JDK versions `1.5' and
     `1.6' are equivalent to `5' or `6', respectively.  Specify a JVM
     (classfile) version to target.  This is useful if (for example) you
     use Java 6, but want to create `.class' files that can run on Java
     5.  In that case specify `--target 5'.

   The options `-C', `-d', `-T', `-P', `--main' `--applet', and
`--servlet' are used to compile a Scheme file; see *note Files
compilation::.  The option `--connect portnum' is only used by the
`kawa' front-end program.

2.1.6 Options for debugging
---------------------------

The following options are useful if you want to debug or understand how
Kawa works.
`--debug-dump-zip'
     Normally, when Kawa loads a soyrce file, or evaluates a non-trivial
     expression, it generates new internal Java classes but does not
     write them out.  This option asks it to write out generated classes
     in a `.zip' archive whose name has the prefix `kawa-zip-dump-'.

`--debug-print-expr'
     Kawa translates source language forms into an internal `Expression'
     data structure.  This option causes that data structure to be
     written out in a readable format to the standard output.

`--debug-print-final-expr'
     Similar to the previous option, but prints out the `Expression'
     after various transformations and optimizations have been done, and
     just before code generation.

`--debug-error-prints-stack-trace'
     Prints a stack trace with any error found during compilation.

`--debug-warning-prints-stack-trace'
     Prints a stack trace with any warning found during compilation.

2.1.7 Options for web servers
-----------------------------

JDK 6, the standard Java 6 distribution by Sun/Oracle, includes a
complete web server library.

`--http-auto-handler context-path appdir'
     Register a web application handler that uses files in the directory
     appdir to handle HTTP (web) requests containing the given
     context-path.  That is it handles requests that start with
     `http://localhost:portcontext-path'.  (This assumes the
     context-path starts with a `/'.)  *Note Self-configuring page
     scripts::.

`--http-start port'
     Start the web server, listing on the specified port.


File: kawa.info,  Node: Scripts,  Next: New-Window,  Prev: Options,  Up: Running

2.2 Running Command Scripts
===========================

Unix-like systems support a mechanism where a "script" can specify a
program that should execute it.  The convention is that the first line
of the file should start with the two characters `#!' followed by the
absolute path of the program that should process (interpret) the script.

   This is convention works well for script languages that use `#' to
indicate the start of a comment, since the interpreter will
automatically ignore the line specifying the interpreter filename.
Scheme, however, uses `#' for various special objects, and Kawa
specifically uses `#!' as a prefix for various *note Special named
constants:: such as `#!optional'.

   Kawa does recognize the three-character sequence `#!/' at the
beginning of a file as special, and ignores it.  So you can specify
command interpreters, as long as you don't put a space between the `#!'
and the interpreter filename.  Here is an example:
     #!/usr/local/bin/kawa
     (format #t "The time is ~s~%" (make <java.util.Date>))

   If this file has the execute permission set and is in your `PATH',
then you can execute it just by naming it on command line.  The system
kernel will automatically execute `kawa', passing it the filename as an
argument.

   Note that the full path-name of the `kawa' interpreter must be
hard-wired into the script.  This means you may have to edit the script
depending on where Kawa is installed on your system.  Another possible
problem is that the interpreter must be an actual program, not a shell
script. Depending on how you configure and install Kawa, `kawa' can be a
real program or a script.  You can avoid both problems by the `env'
program, available on most modern Unix-like systems:

     #!/usr/bin/env kawa
     (format #t "The time is ~s~%" (make <java.util.Date>))

   If you need to specify extra arguments to `kawa', you can use the
following trick:
     #!/bin/sh
     exec kawa --commonlisp out:base=16 --script2 "$0" "$@"
     (setq xx 20) (display xx) (newline)
   This causes the shell to invoke the `kawa' program.  This assumes
`kawa' is in the command path; if not replace `kawa' by the appropriate
incantation, which can be multiple words (for example `java kawa.repl').
The `exec' tells the shell to _replace_ itself by kawa; this is
important so the shell doesn't continue with this file when done with
`kawa'.  The rest of the line can contain whatever commands and options
you want when executing Kawa.  The important part is `--script2 "$0"'.
The shell replaces the `"$0"' by the name the script, and replaces the
`"$@"' by the remaining arguments passed to the script.  So what Kawa
sees is the `--script2' option followed the script name, followed by
remaining command-line arguments.  The `--script2' tells Kawa to execute
the script, after ignoring the initial two lines, which would confuse it
terribly.


File: kawa.info,  Node: New-Window,  Next: Exiting,  Prev: Scripts,  Up: Running

2.3 Running a Command Interpreter in a new Window
=================================================

An alternative interface runs the Java read-eval-print-loop inside a new
window. This is in some ways nicer.  One reason is that it provides
better editing.  You can also create new windows.  They can either have
different top-level environments or they can share environments.  To try
it, do:
     java kawa.repl -w


File: kawa.info,  Node: Exiting,  Prev: New-Window,  Up: Running

2.4 Exiting Kawa
================

Kawa normally keeps running as long as there is an active
read-eval-print loop still awaiting input or there is an unfinished
other computation (such as requested by a `-e' of `-f' option).

   To close a read-eval-print-loop, you can type the special literal
`#!eof' at top level.  This is recognized as end-of-file.
Unfortunately, due to thread-related complications, just typing an
end-of-file character (normally ctrl/D until Unix), will not work.

   If the read-eval-print-loop is in a new window, you can select
`Close' from the `File' menu.

   To exit the entire Kawa session, call the `exit' procedure (with 0 or
1 integer arguments).


File: kawa.info,  Node: Compiling,  Up: Running

2.5 Compiling to byte-code or an executable
===========================================

All Scheme functions and source files are invisibly compiled into
internal Java byte-codes.  (A traditional interpreter is used for
macro-expansion.  Kawa used to also interpret “simple” expressions in
interactive mode, but always compiling makes things more consistent, and
allows for better stack traces on errors.)

   To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.  There are
two ways to do this.

   You can compile a Scheme source file to a single archive file.  You
do this using the `compile-file' function.  The result is a single file
that you can move around and `load' just like the `.scm' source file.
You just specify the name of the archive file to the `load' procedure.
Currently, the archive is a "zip" archive and has extension ".zip"; a
future release will probably use "Java Archive" (jar) files.  The
advantage of compiling to an archive is that it is simple and
transparent.  A minor disadvantage is that it causes the Java "verifier"
to be run when functions are loaded from it, which takes a little extra
time.

   Alternatively, you can compile a Scheme source file to a collection
of `.class' files.  You then use the standard Java class loading
mechanism to load the code.  The Java "verifier" does not need to get
run, which makes loading a little faster.  The compiled class files do
have to be installed somewhere in the `CLASSPATH'.

   You can also compile your Scheme program to native code using GCJ.

* Menu:

* Archive compilation::         Compiling to an archive file
* Files compilation::           Compiling to a set of .class files
* Compilation options::
* Compiling using Ant::
* Application compilation::     Compiling to a standalone application
* Applet compilation::          Compiling to an applet
* Compiling to executable::     Compiling to a native executable


File: kawa.info,  Node: Archive compilation,  Next: Files compilation,  Prev: Compiling,  Up: Compiling

2.5.1 Compiling to an archive file
----------------------------------

 -- Procedure: compile-file source-file compiled-archive
     Compile the source-file, producing a `.zip' archive compiled-file.

     For example, to byte-compile a file `foo.scm' do:

          (compile-file "foo.scm" "foo")

     This will create `foo.zip', which contains byte-compiled "j-code".
     You can move this file around, without worrying about class paths.
     To load the compiled file, you can later `load' the named file, as
     in either `(load "foo")' or `(load "foo.zip")'.  This should have
     the same effect as loading `foo.scm', except you will get the
     faster byte-compiled versions.


File: kawa.info,  Node: Files compilation,  Next: Compilation options,  Prev: Archive compilation,  Up: Compiling

2.5.2 Compiling to a set of .class files
----------------------------------------

Invoking `kawa' (or `java kawa.repl') with the `-C' flag will compile a
`.scm' source file into one or more `.class' files:
     kawa --main -C myprog.scm

   You run it as follows:
     kawa [-d outdirectory] [-P prefix] [-T topname] [--main | --applet | --servlet] -C infile ...

   Note the `-C' must come last, because `Kawa' processes the arguments
and options in order,

   Here:
`-C infile ...'
     The Scheme source files we want to compile.

`-d outdirectory'
     The directory under which the resulting `.class' files will be.
     The default is the current directory.

`-P prefix'
     A string to prepend to the generated class names.  The default is
     the empty string.

`-T topname'
     The name of the "top" class - i.e. the one that contains the code
     for the top-level expressions and definitions.  The default is
     generated from the infile and prefix.

`--main'
     Generate a `main' method so that the resulting "top" class can be
     used as a stand-alone application. *Note Application compilation::.

`--applet'
     The resulting class inherits from `java.applet.Applet', and can be
     used as an applet.  *Note Applet compilation::.

`--servlet'
     The resulting class implements `javax.servlet.http.HttpServlet',
     and can be used as an servlet in a servlet container like Tomcat.

   When you actually want to load the classes, the outdirectory must be
in your `CLASSPATH'.  You can use the standard `load' function to load
the code, by specifying the top-level class, either as a file name
(relative to outdirectory) or a class name.  E.g. if you did:
     kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
   you can use either:
     (load "my.lib.foo")
   or:
     (load "my/lib/foo.class")

   If you are compiling a Scheme source file (say `foosrc.scm') that
uses macros defined in some other file (say `macs.scm'), you need to
make sure the definitions are visible to the compiler.  One way to do
that is with the `-f':
     kawa -f macs.scm -C foosrc.scm


File: kawa.info,  Node: Compilation options,  Next: Compiling using Ant,  Prev: Files compilation,  Up: Compiling

2.5.3 Compilation options
-------------------------

Various named option control how Kawa compiles certain forms.

`--module-static'
     If no `module-static' is specified, generate a static module (as if
     `(module-static #t)' were specified). *Note Module classes::.  This
     is (now) the default.

`--module-nonstatic'
`--no-module-static'
     If no `module-static' is specified, generate a non-static module
     (as if `(module-static #f)' were specified). *Note Module
     classes::.  This used to be the default.

`--module-static-run'
     If no `module-static' is specified, generate a static module (as if
     `(module-static 'init-run)' were specified). *Note Module
     classes::.

`--warn-unknown-member'
     Emit a warning if the code references a named member (field or
     method) for which there is no match in the compile-time type of the
     receiver.  This defaults to on; to turn it off use the
     `--no-warn-unknown-member' flag.

`--warn-invoke-unknown-method'
     Emit a warning if the `invoke' function calls a named method for
     which there is no matching method in the compile-time type of the
     receiver.  This defaults to the value of `--warn-unknown-member',
     to turn it off use the `--no-warn-invoke-unknown-method' flag.

`--warn-undefined-variable'
     Emit a warning if the code references a variable which is neither
     in lexical scope nor in the compile-time dynamic (global)
     environment.  This is useful for catching typos.  (A
     `define-variable' form can be used to silence warnings.  It
     declares to the compiler that a variable is to be resolved
     dynamically.)

`--warn-as-error'
     Treat a compilation warning as if it were an error and halt
     compilation.

   An option can be followed by a value, as in
`--warn-invoke-unknown-method=no'.  For boolean options, the values
`yes', `true', `on', or `1' enable the option, while `no', `false',
`off', or `0' disable it.  You can also negate an option by prefixing it
with `no-': The option `--no-warn-unknown-member' is the same as
`--warn-unknown-member=no'.

   You can set the same options within your Scheme source file.  (In
that case they override the options on the command line.)

 -- Syntax: module-compile-options [key: value] ...
     This sets the value of the `key' option to `value' for the current
     module (source file).  It takes effect as soon it is seen during
     the first macro-expansion pass, and is active thereafter (unless
     overridden by `with-compile-options').

     The key is one of the above option names.  (The following colon
     make it a Kawa keyword.)  The value must be a literal value: either
     a boolean (`#t' or `#f'), a number, or a string, depending on the
     key.  (All the options so far are boolean options.)

          (module-compile-options warn-undefined-variable: #t)
          ;; This causes a warning message that y is unknown.
          (define (func x) (list x y))

 -- Syntax: with-compile-options [key: value] ... body
     Similar to `module-compile-options', but the option is only active
     within body.

          (define (func x)
            (with-compile-options warn-invoke-unknown-method: #f
              (invoke x 'size)))


File: kawa.info,  Node: Compiling using Ant,  Next: Application compilation,  Prev: Compilation options,  Up: Compiling

2.5.4 Compiling using Ant
-------------------------

Many Java projects use Ant (http://ant.apache.org) for building Java
projects.  Kawa includes a `<kawac>' Ant ask that simplifies compiling
Kawa sources files to classes.  See the `build.xml' in the Kawa source
distribution for examples.  See the `kawac' task documentation
(ant-kawac.html) for details.


File: kawa.info,  Node: Application compilation,  Next: Applet compilation,  Prev: Compiling using Ant,  Up: Compiling

2.5.5 Compiling to a standalone application
-------------------------------------------

A Java application is a Java class with a special method (whose name is
`main').  The application can be invoked directly by naming it in the
Java command.  If you want to generate an application from a Scheme
program, create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.  You can
compile in the regular way decribed in the previous section, but add the
`--main' option.  For example, assuming your Scheme file is
`MyProgram.scm':
     kawa --main -C MyProgram.scm
   This will create a `MyProgram.class' which you can either `load' (as
decribed in the previous section), or invoke as an application:
     java MyProgram [args]
   Your Scheme program can access the command-line arguments args by
using the global variable `command-line-arguments', or the R6RS function
`command-line'.

   If there is no explicit `module-export' in a module compiled with
`--main' then no names are exported.  (The default otherwise is for all
names to be exported.)


File: kawa.info,  Node: Applet compilation,  Next: Compiling to executable,  Prev: Application compilation,  Up: Compiling

2.5.6 Compiling to an applet
----------------------------

An applet is a Java class that inherits from `java.applet.Applet'.  The
applet can be downloaded and run in a Java-capable web-browser.  To
generate an applet from a Scheme program, write the Scheme program with
appropriate definitions of the functions `init', `start', `stop' and
`destroy'.  You must declare these as zero-argument functions with a
`<void>' return-type.

   Here is an example, based on the scribble applet in Flanagan's "Java
Examples in a Nutshell" (O'Reilly, 1997):
     (define-private last-x 0)
     (define-private last-y 0)

     (define (init) :: void
       (let ((applet (this)))
         (applet:addMouseListener
          (object (java.awt.event.MouseAdapter)
     	     ((mousePressed e)
     	      (set! last-x (e:getX))
     	      (set! last-y (e:getY)))))
         (applet:addMouseMotionListener
          (object (java.awt.event.MouseMotionAdapter)
     	     ((mouseDragged e)
     	      (let ((g (applet:getGraphics))
     		    (x (e:getX))
     		    (y (e:getY)))
     		(g:drawLine last-x last-y x y)
     		(set! last-x x)
     		(set! last-y y)))))))

     (define (start) :: void (format #t "called start.~%~!"))
     (define (stop) :: void (format #t "called stop.~%~!"))
     (define (destroy) :: void (format #t "called destroy.~%~!"))

   You compile the program with the `--applet' flag in addition to the
normal `-C' flag:
     java kawa.repl --applet -C scribble.scm

   You can then create a `.jar' archive containing your applet:
     jar cf scribble.jar scribble*.class

   Finally, you create an `.html' page referencing your applet and its
support `jar's:
     <html><head><title>Scribble testapp</title></head>
     <body><h1>Scribble testapp</h1>
     You can scribble here:
     <br>
     <applet code="scribble.class" archive="scribble.jar, kawa-1.11.jar" width=200 height=200>
     Sorry, Java is needed.</applet>
     </body></html>

   The problem with using Kawa to write applets is that the Kawa `.jar'
file is quite big, and may take a while to download over a network
connection.  Some possible solutions:

   • Try to strip out of the Kawa `.jar' any classes your applet doesn't
     need.

   • Java 2 provides a mechanism to install a download extension
     (http://java.sun.com/docs/books/tutorial/ext/basics/download.html).

   • Consider some alternative to applets, such as Java Web Start
     (http://java.sun.com/products/javawebstart/).


File: kawa.info,  Node: Compiling to executable,  Prev: Applet compilation,  Up: Compiling

2.5.7 Compiling to a native executable
--------------------------------------

You can compile your Scheme program to native code using GCJ, as long as
you have built Kawa using GCJ.

   First, you need to compile the Scheme code to a set of `.class'
files; see *note Files compilation::.
     kawa --main -C myprog.scm

   Then to create an executable `myprog' do:
     gckawa --main=myprog myprog*.class -o myprog

   The `gckawa' is a simple shell script that calls `gcj'.  The reason
for the wildcard in `myprog*.class' is that sometimes Kawa will generate
some helper classes in addition to `myprog.class'.  The `--main' option
tell `gcj' which class contains the `main' method it should use.  The
`-o' option names the resulting executable program.  The `-lkawa' option
tells the linker it should link with the kawa shared library, and the
`-L$PREFIX/bin' option tells the linker where it can find that library.


File: kawa.info,  Node: Features,  Next: Syntax,  Prev: Running,  Up: Top

3 Summary of Kawa Scheme Features
*********************************

This manual mostly documents how Kawa Scheme differs from standard
(R5RS) Scheme, though the goal is to merge in information about standard
Scheme here as well.

   Kawa is a full Scheme implementation.  It implements almost all of
R5RS (for exceptions *note Restrictions::), plus some extensions.  By
default, symbols are case sensitive.

   It is completely written in Java.  Scheme functions and files are
automatically compiled into Java byte-codes.  Kawa does some
optimizations, and the compiled code runs at reasonable speed.

   Kawa uses Unicode internally, and uses the Java facilities to convert
files using other character encodings.

   Kawa provides the usual read-eval-print loop, as well as batch modes.

   Kawa provides a framework for implementing other progressing
languages, and comes with incomplete support for CommonLisp, Emacs Lisp,
and EcmaScript, and the draft XML Query language
(http://www.gnu.org/software/qexo/).

   Kawa is written in an object-oriented style.

   Kawa has builtin pretty-printer support, and fancy formatting.

   Kawa supports class-definition facilities, and separately-compiled
modules.

   Kawa implements the full numeric tower, including infinite-precision
rational numbers and complex numbers.  It also supports "quantities"
with units, such as `3cm'.

   You can optionally declare the types of variables.

   You can conveniently access Java objects, methods, fields, and
classes.

   Kawa implements most of the features of the expression language of
DSSSL, the Scheme-derived ISO-standard Document Style Semantics and
Specification Language for SGML.  Of the core expression language, the
only features missing are character properties, `external-procedure',
the time-relationed procedures, and character name escapes in string
literals.  Also, Kawa is not generally tail-recursive.  From the full
expression language, Kawa additionally is missing `format-number',
`format-number-list', and language objects.  Quantities, keyword values,
and the expanded `lambda' form (with optional and keyword parameters)
are supported.

* Menu:

* Implemented SRFIs::
* Restrictions::


File: kawa.info,  Node: Implemented SRFIs,  Next: Restrictions,  Up: Features

3.1 Implemented SRFIs
=====================

Kawa implements the following semi-standard SRFIs (Scheme Request for
Implementation (http://srfi.schemers.org/)):
   • SRFI 0 (http://srfi.schemers.org/srfi-0/srfi-0.html): Feature-based
     conditional expansion construct, using `cond-expand' - *note Syntax
     and conditional compilation::.

   • SRFI 1 (http://srfi.schemers.org/srfi-1/srfi-1.html): List Library,
     if `(require 'list-lib)'.

   • SRFI 2 (http://srfi.schemers.org/srfi-2/srfi-2.html): AND-LET*: an
     AND with local bindings, a guarded LET* special form.

   • SRFI 4 (http://srfi.schemers.org/srfi-4/srfi-4.html): Homogeneous
     numeric vector datatypes - *note Uniform vectors::.

   • SRFI 6 (http://srfi.schemers.org/srfi-6/srfi-6.html): Basic String
     Ports - *note Ports::.

   • SRFI 8 (http://srfi.schemers.org/srfi-8/srfi-8.html): `receive':
     Binding to multiple values - *note Multiple values::.

   • SRFI 9 (http://srfi.schemers.org/srfi-9/srfi-9.html): Defining
     Record Types, using `define-record-type' - *note Record types::.

   • SRFI 11 (http://srfi.schemers.org/srfi-11/srfi-11.html): Syntax for
     receiving multiple values, using `let-values' and `let*-value' -
     *note Multiple values::.

   • SRFI 13 (http://srfi.schemers.org/srfi-13/srfi-13.html): String
     Library.  Needs some polishing.

   • SRFI 16 (http://srfi.schemers.org/srfi-16/srfi-16.html): Syntax for
     procedures of variable arity, using `case-lambda'
     (http://srfi.schemers.org/srfi-16/srfi-16.html).

   • SRFI 17 (http://srfi.schemers.org/srfi-17/srfi-17.html):
     Generalized `set!' - *note Locations::.

   • SRFI 23 (http://srfi.schemers.org/srfi-23/srfi-23.html): Error
     reporting mechanism, using `error' - *note Exceptions::.

   • SRFI 25 (http://srfi.schemers.org/srfi-25/srfi-25.html):
     Multi-dimensional Array Primitives - *note Arrays::.

   • SRFI 26 (http://srfi.schemers.org/srfi-26/srfi-26.html): Notation
     for Specializing Parameters without Currying - *note Procedures::.

   • SRFI 28 (http://srfi.schemers.org/srfi-28/srfi-28.html): Basic
     Format Strings - *note Format::.

   • SRFI 30 (http://srfi.schemers.org/srfi-30/srfi-30.html): Nested
     Multi-line Comments.

   • SRFI 37 (http://srfi.schemers.org/srfi-37/srfi-37.html):
     `args-fold' - a program argument processor
     (http://srfi.schemers.org/srfi-37/srfi-37.html), if `(require
     'args-fold)'.

   • SRFI 39 (http://srfi.schemers.org/srfi-39/srfi-39.html): *Note
     Parameter objects::.

   • SRFI 62 (http://srfi.schemers.org/srfi-62/srfi-62.html):
     S-expression comments.

   • SRFI 64 (http://srfi.schemers.org/srfi-64/srfi-64.html): A Scheme
     API for test suites.

   • SRFI 69 (http://srfi.schemers.org/srfi-69/srfi-69.html): Basic hash
     tables - *note Hash tables::.

   • SRFI 88 (http://srfi.schemers.org/srfi-88/srfi-88.html): Keyword
     objects - *note Keywords::.

   • SRFI 95 (http://srfi.schemers.org/srfi-95/srfi-95.html): Sorting
     and Merging.

   • SRFI 97 (http://srfi.schemers.org/srfi-97/srfi-97.html): Names for
     SRFI Libraries.


File: kawa.info,  Node: Restrictions,  Prev: Implemented SRFIs,  Up: Features

3.2 Features of R5RS not implemented
====================================

Kawa implements all the required and optional features of R5RS, with the
following exceptions.

   The entire "numeric tower" is implemented.  However, some
transcendental function only work on reals.  Integral function do not
necessarily work on inexact (floating-point) integers.  (The whole idea
of "inexact integer" in R5RS seems rather pointless ...)

   Also, `call-with-current-continuation' is only "upwards" (?).  I.e.
once a continuation has been exited, it cannot be invoked.  These
restricted continuations can be used to implement catch/throw (such as
the examples in R4RS), but not co-routines or backtracking.

   Kawa now does general tail-call elimination, but only if you use the
flag `--full-tail-calls'.  (Currently, the `eval' function itself is not
fully tail-recursive, in violation of R5RS.)   The `--full-tail-calls'
flag is not on by default, partly because it is noticably slower (though
I have not measured how much), and partly I think it is more useful for
Kawa to be compilatible with standard Java calling conventions and
tools.  Code compiled with `--full-tail-calls' can call code  compiled
without it and vice versa.

   Even without `--full-tail-calls', if the compiler can prove that the
procedure being called is the current function, then the tail call will
be replaced by a jump.  This means the procedure must be defined using a
letrec, not a define (because the compiler does not know if someone
might re-define a global definition), and there must be no assignments
(using `set!') to the procedure binding.


File: kawa.info,  Node: Syntax,  Next: Multiple values,  Prev: Features,  Up: Top

4 Syntax
********

* Menu:

* Syntax notation::
* Lexical and datum syntax::
* Lexical syntax::
* Datum syntax::
* Hash-prefixed forms::
* Syntax and conditional compilation::


File: kawa.info,  Node: Syntax notation,  Next: Lexical and datum syntax,  Up: Syntax

4.1 Notation
============

The formal syntax for Kawa Scheme is written in an extended BNF.
Non–terminals are written like-this.  Case is insignificant for
non–terminal names.  Literal text (terminals) are written `like this'.

   All spaces in the grammar are for legibility.

   The following extensions to BNF are used to make the description more
concise: thing* or thing`...' both mean zero or more occurrences of
thing, and thing+ means at least one thing.

   Some non-terminal names refer to the Unicode scalar values of the
same name: character-tabulation (U+0009), linefeed (U+000A),
carriage-return (U+000D), line-tabulation (U+000B), form-feed (U+000C),
space (U+0020), next-line (U+0085), line-separator (U+2028), and
paragraph-separator (U+2029).


File: kawa.info,  Node: Lexical and datum syntax,  Next: Lexical syntax,  Prev: Syntax notation,  Up: Syntax

4.2 Lexical and datum syntax
============================

The syntax of Scheme code is organized in three levels:

  1. the _lexical syntax_ that describes how a program text is split
     into a sequence of lexemes,

  2. the _datum syntax_, formulated in terms of the lexical syntax, that
     structures the lexeme sequence as a sequence of _syntactic data_,
     where a syntactic datum is a recursively structured entity,

  3. the _program syntax_ formulated in terms of the datum syntax,
     imposing further structure and assigning meaning to syntactic data.

   Syntactic data (also called _external representations_) double as a
notation for objects, and the `READ' and `WRITE' procedures can be used
for reading and writing syntactic data, converting between their textual
representation and the corresponding objects.  Each syntactic datum
represents a corresponding _datum value_.  A syntactic datum can be used
in a program to obtain the corresponding datum value using `quote'.

   Scheme source code consists of syntactic data and (non–significant)
comments.  Syntactic data in Scheme source code are called _forms_.  (A
form nested inside another form is called a _subform_.)  Consequently,
Scheme's syntax has the property that any sequence of characters that is
a form is also a syntactic datum representing some object.  This can
lead to confusion, since it may not be obvious out of context whether a
given sequence of characters is intended to be a representation of
objects or the text of a program.  It is also a source of power, since
it facilitates writing programs such as interpreters or compilers that
treat programs as objects (or vice versa).

   A datum value may have several different external representations.
For example, both `#e28.000' and `#x1c' are syntactic data representing
the exact integer object 28, and the syntactic data `(8 13)', `( 08 13
)', `(8 . (13 . ()))' all represent a list containing the exact integer
objects 8 and 13.  Syntactic data that represent equal objects (in the
sense of `EQUAL?') are always equivalent as forms of a program.

   Because of the close correspondence between syntactic data and datum
values, we sometimes uses the term _datum_ for either a syntactic datum
or a datum value when the exact meaning is apparent from the context.


File: kawa.info,  Node: Lexical syntax,  Next: Datum syntax,  Prev: Lexical and datum syntax,  Up: Syntax

4.3 Lexical syntax
==================

The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non–significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the Unicode standard (http://unicode.org/).  Some of the lexemes,
such as identifiers, representations of number objects, strings etc., of
the lexical syntax are syntactic data in the datum syntax, and thus
represent objects.  Besides the formal account of the syntax, this
section also describes what datum values are represented by these
syntactic data.

   The lexical syntax, in the description of comments, contains a
forward reference to datum, which is described as part of the datum
syntax.  Being comments, however, these datums do not play a significant
role in the syntax.

   Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, `#x1A' and `#X1a' are equivalent.  The identifier `Foo' is,
however, distinct from the identifier `FOO'.

4.3.1 Formal account
--------------------

Interlexeme space may occur on either side of any lexeme, but not within
a lexeme.

   Identifiers, `.', numbers, characters, and booleans, must be
terminated by a delimiter or by the end of the input.

     lexeme `::=' identifier | boolean | number
              | character | string
              | `(' |  `)' |  `[' |  `]' |  `#('
              | `'' | ``' | `,' | `,@' | `.'
              | `#'' |  `#`' |  `#,' |  `#,@'
     delimiter `::=' `(' |  `)' |  `[' | `]' | `"' | `'; | `#'
              | whitespace

   ((UNFINISHED))

4.3.2 Line endings
------------------

Line endings are significant in Scheme in single–line comments and
within string literals.  In Scheme source code, any of the line endings
in line-ending marks the end of a line.  Moreover, the two–character
line endings carriage-return linefeed and carriage-return next-line each
count as a single line ending.

   In a string literal, a line-ending not preceded by a `\' stands for a
linefeed character, which is the standard line–ending character of
Scheme.

4.3.3 Whitespace and comments
-----------------------------

     whitespace `::=' character-tabulation
              | linefeed | line-tabulation | form-feed
              | carriage-return | next-line
              | any character whose category is Zs, Zl, or Zp
     line ending `::=' linefeed | carriage return
              | carriage-return linefeed | next-line
              | carriage-return next-line | line-separator
     comment `::='  `;' all subsequent characters up to a line-ending
                     or paragraph-separator
              | nested comment
              | `#;' interlexeme-space datum
     nested-comment `::='  `#|' comment-text comment-cont* `|#'
     comment-text `::=' character sequence not containing `#|' or `|#'
     comment-cont `::=' nested-comment comment-text
     atmosphere `::=' whitespace | comment
     interlexeme-space `::=' atmosphere*

_Whitespace_ characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

   The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

   A semicolon (`;') indicates the start of a line comment.  The comment
continues to the end of the line on which the semicolon appears.

   Another way to indicate a comment is to prefix a datum (cf.  section
“Formal account”) with `#;', possibly with interlexeme-space before the
datum.  The comment consists of the comment prefix `#;' and the datum
together.  This notation is useful for “commenting out” sections of
code.

   Block comments may be indicated with properly nested `#|' and `|#'
pairs.
     #|
        The FACT procedure computes the factorial of a
        non-negative integer.
     |#
     (define fact
       (lambda (n)
         ;; base case
         (if (= n 0)
             #;(= n 1)
             1       ; identity of *
             (* n (fact (- n 1))))))

4.3.4 Identifiers
-----------------

     identifier `::=' initial subsequent*
              | peculiar-identifier
     initial `::='  constituent | special-initial
              | inline-hex-escape
     letter `::=' `a' | `b' | `c' | ... | `z'
              | `A' | `B' | `C' | ... | `Z'
     constituent `::=' letter
              | any character whose Unicode scalar value is greater than
                  127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
                  Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co
     special-initial `::=' `!' | `$' | `%' | `&' | `*' | `/' | `<' | `='
              | `>' | `?' | `^' | `_' | `~'
     subsequent `::=' initial | digit
              | any character whose category is Nd, Mc, or Me
              | special-subsequent
     digit `::=' `0' | `1' | `2' | `3' | `4' | `5' | `6' | `7' | `8' | `9'
     hex-digit `::=' digit
              | `a' | `A' | `b' | `B' | `c' | `C' | `d' | `D' | `e' | `E' | `f' | `F'
     special-subsequent `::=' `+' | `-' | `.' | `@'
     escape-sequence `::=' inline-hex-escape
              | `\'character-except-x
              | multi-escape-sequence
     inline-hex-escape `::=' `\x'hex-scalar-value`;'
     hex-scalar-value `::=' hex-digit+
     multi-escape-sequence `::=' `|'character-except-vbar...`|'
     character-except-vbar `::=' any character except `|'
     character-except-x `::=' any character except `x'
     peculiar-identifier `::=' `+' | `-' | `...' | `->' subsequent*

   Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
“extended alphabetic characters” is an identifier when it begins with a
character that cannot begin a representation of a number object.  In
addition, `+', `-', and `...' are identifiers, as is a sequence of
letters, digits, and extended alphabetic characters that begins with the
two–character sequence `->'.  Here are some examples of identifiers:

     lambda         q                soup
     list->vector   +                V17a
     <=             a34kTMNs         ->-
     the-word-recursion-has-many-meanings

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

     ! $ % & * + - . / < = > ? @ ^ _ ~

   Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified using an escape-sequence.  For example, the
identifier `H\x65;llo' is the same as the identifier `Hello'.

   Kawa supports two additional non-R6RS ways of making identifiers
using special characters, both taken from Common Lisp: Any character
(except `x') following a backslash is treated as if it were a letter; as
is any character between a pair of vertical bars.

   Any identifier may be used as a variable or as a syntactic keyword in
a Scheme program.  Any identifier may also be used as a syntactic datum,
in which case it represents a _symbol_.

   Note that colon `:' is treated specially for the “colon operator”
(FIXME NEEDS DOCUMENTATION) in Kawa Scheme, though it is special-initial
in standard Scheme (R6RS).


File: kawa.info,  Node: Datum syntax,  Next: Hash-prefixed forms,  Prev: Lexical syntax,  Up: Syntax

4.4 Datum syntax
================

The datum syntax describes the syntax of syntactic data in terms of a
sequence of lexemes, as defined in the lexical syntax.

   The following grammar describes the syntax of syntactic data in terms
of various kinds of lexemes defined in the grammar in section “Lexical
Syntax”:

     datum `::=' defining-datum
              | nondefining-datum
              | defined-datum

     defining-datum `::=' `#'indexnum`='nondefining-datum
     defined-datum `::=' `#'indexnum`#'
     nondefining-datum `::=' lexeme-datum
              | compound-datum
     indexnum `::=' digit-10+

     lexeme-datum `::=' boolean | number
              | character | string | symbol
     symbol `::=' identifier
     compound-datum `::=' list | vector | uniform-vector | xml-literal
     list `::=' `('datum*`)'
              | `('datum+ `.' datum`)'
              | abbreviation
     abbreviation `::=' abbrev-prefix datum
     abbrev-prefix `::=' `'' | ``' | `,' | `,@'
              | `#'' | `#`'
     vector `::=' `#('datum*`)'
     uniform-vector `::=' TODO

4.4.1 Abbreviations
-------------------

The following are abbreviations:

`''datum
     for `(quote datum)',

``'datum
     for `(quasiquote datum)',

`,'datum
     for `(unquote datum)',

`,@'datum
     for `(unquote-splicing datum)',

`#''datum
     for `(syntax datum)', and

`#`'datum
     for `(quasisyntax datum)'.


File: kawa.info,  Node: Hash-prefixed forms,  Next: Syntax and conditional compilation,  Prev: Datum syntax,  Up: Syntax

4.5 Hash-prefixed forms
=======================

A number of different special forms are indicated by an initial hash
(number) symbols (`#').  Here is a table summarizing them.

   Case is ignored for the character followed the `#'.  Thus `#x' and
`#X' are the same.

`#:'keyword
     Guile-style keyword syntax (deprecated).

`#\'
     Character literals.

`#!'
     *Note Special named constants::.

`#`'datum
     Equivalent to `(quasisyntax datum)'.  Convenience syntax for
     syntax-case macros.

`#''datum
     Equivalent to `(syntax datum)'.  Convenience syntax for syntax-case
     macros.

`#('
     A vector.

`#|'
     Start of nested-comment.

`#/'regex`/'
     *Note Regular expressions::.

`#<'
     *Note XML literals::.

`#;'datum
     A datum comment - the datum is ignored.  (An interlexeme-space may
     appear before the datum.)

`#,('name datum ...`)'
     Special named constructors.

`#'number`='datum
     A reference definition, allowing cyclic and shared structure.
     Equivalent to the datum, but also defines an association between
     the integer number and that datum, which can be used by a
     subsequent `#number#' form.

`#'number`#'
     A back-reference, allowing cyclic and shared structure.

`#b'
     A binary (base-2) number.

`#d'
     A decimal (base-10) number.

`#e'
     A prefix to treat the following number as exact.

`#f'
     The standard boolean false object.

`#f'n`('number ...`)'
     A uniform vector of floating-point numbers.  The parameter n is a
     precision, which can be 32 or 64.  *Note Uniform vectors::.

`#i'
     A prefix to treat the following number as inexact.

`#o'
     An octal (base-8) number.

`#'base`r'
     A number in the specified base (radix).

`#s'n`('number ...`)'
     A uniform vector of signed integers.  The parameter n is a
     precision, which can be 8, 16, 32, or 64.  *Note Uniform vectors::.

`#t'
     The standard boolean true object.

`#u'n`('number ...`)'
     A uniform vector of unsigned integers.  The parameter n is a
     precision, which can be 8, 16, 32, or 64.  *Note Uniform vectors::.

`#x'
     A hexadecimal (base-16) number.

   The follow named constructor forms are supported:

`#,(path' path`)'

`#,(filepath' path`)'

`#,(URI' path`)'

`#,(symbol' local-name [uri [prefix]]`)'
`#,(symbol' local-name namespace`)'

`#,(namespace' uri [prefix]`)'

`#,(duration' duration`)'


File: kawa.info,  Node: Syntax and conditional compilation,  Prev: Hash-prefixed forms,  Up: Syntax

4.6 Syntax and conditional compilation
======================================

Kawa supports most of the `syntax-case' feature.

 -- Syntax: define-syntax ..
     Pattern ...

 -- Syntax: define-syntax-case name `('literals`)' `('pattern expr`)'
          ...
     A convenience macro to make it easy to define `syntax-case'-style
     macros.  Defines a macros with the given name and list of literals.
     Each pattern has the form of a `syntax-rules'-style pattern, and it
     is matched against the macro invocation syntax form.  When a match
     is found, the corresponding expr is evaluated.  It must evaluate to
     a syntax form, which replaces the macro invocation.

 -- Syntax: define-macro `('name lambda-list`)' form ...
     _This form is deprecated._  Functionally equivalent to `defmacro'.

 -- Syntax: defmacro name lambda-list form ...
     _This form is deprecated._  Instead of

          (defmacro (name ...)
            (let ... `(... ,exp ...)))

     you should probably do:

          (define-syntax-case name ()
            ((_ ...) (let #`(... exp ...))))

     and instead of

          (defmacro (name ... var ...) `(... var ...))

     you should probably do:

          (define-syntax-case name ()
            ((_ ... var ...) #`(... var ...))

     Defines an old-style macro a la Common Lisp, and installs `(lambda
     lambda-list form ...)' as the expansion function for name.  When
     the translator sees an application of name, the expansion function
     is called with the rest of the application as the actual arguments.
     The resulting object must be a Scheme source form that is futher
     processed (it may be repeatedly macro-expanded).

 -- Procedure: gentemp
     Returns a new (interned) symbol each time it is called.  The symbol
     names are implementation-dependent.  (This is not directly
     macro-related, but is often used in conjunction with `defmacro' to
     get a fresh unique identifier.)

 -- Syntax: cond-expand cond-expand-clause* [`(else'
          command-or-definition*`)']

          cond-expand-clause `::=' `('feature-requirement command-or-definition*`)'
          feature-requirement `::=' feature-identifier
            | `(and' feature-requirement*`)'
            | `(or' feature-requirement*`)'
            | `(not' feature-requirement`)'
          feature-identifier `::=' a symbol which is the name or alias of a SRFI

     The `cond-expand' form tests for the existence of features at
     macro-expansion time. It either expands into the body of one of its
     clauses or signals an error during syntactic processing.
     `cond-expand' expands into the body of the first clause whose
     feature requirement is currently satisfied; the `else' clause, if
     present, is selected if none of the previous clauses is selected.

     A feature requirement has an obvious interpretation as a logical
     formula, where the feature-identifier variables have meaning true
     if the feature corresponding to the feature identifier, as
     specified in the SRFI registry, is in effect at the location of the
     `cond-expand' form, and false otherwise. A feature requirement is
     satisfied if its formula is true under this interpretation.

     Examples:

          (cond-expand
              ((and srfi-1 srfi-10)
               (write 1))
              ((or srfi-1 srfi-10)
               (write 2))
              (else))

          (cond-expand
            (command-line
             (define (program-name) (car (argv)))))

     The second example assumes that `command-line' is an alias for some
     feature which gives access to command line arguments. Note that an
     error will be signaled at macro-expansion time if this feature is
     not present.

 -- Syntax: include path
     Read the contents of the file at path as a sequence of forms, and
     treat the result as if the resulting forms were the forms of a
     `begin'.

 -- Syntax: include-relative path
     Same as `include', except that the path is relative to the path of
     the source-file containing the `include-file'.

 -- Procedure: expand form
     The result of evaluating form is treated as a Scheme expression,
     syntax-expanded to internal form, and then converted back to
     (roughly) the equivalent expanded Scheme form.

     This can be useful for debugging macros.

     To access this function, you must first `(require 'syntax-utils)'.

          (require 'syntax-utils)
          (expand '(cond ((> x y) 0) (else 1))) ⇒ (if (> x y) 0 1)


File: kawa.info,  Node: Multiple values,  Next: Symbols and namespaces,  Prev: Syntax,  Up: Top

5 Multiple values
*****************

The multiple-value feature was added in R5RS.

 -- Procedure: values object ...
     Delivers all of its arguments to its continuation.

 -- Procedure: call-with-values thunk receiver
     Call its thunk argument with a continuation that, when passed some
     values, calls the receiver procedure with those values as
     arguments.

 -- Syntax: let-values `(('formals expression`)' ...`)' body
     Each formals should be a formal arguments list as for a `lambda',
     cf section 4.1.4 of the R5RS.

     The expressions are evaluated in the current environment, the
     variables of the formals are bound to fresh locations, the return
     values of the expressions are stored in the variables, the body is
     evaluated in the extended environment, and the values of the last
     expression of body are returned. The body is a "tail body", cf
     section 3.5 of the R5RS.

     The matching of each formals to values is as for the matching of
     formals to arguments in a `lambda' expression, and it is an error
     for an expression to return a number of values that does not match
     its corresponding formals.

          (let-values (((a b . c) (values 1 2 3 4)))
            (list a b c))            ⇒ (1 2 (3 4)) 

          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (let-values (((a b) (values x y))
                         ((x y) (values a b)))
              (list a b x y)))       ⇒ (x y a b)

 -- Syntax: let*-values `(('formals expression`)' ...`)' body
     Each formals should be a formal arguments list as for a `lambda'
     expression, cf section 4.1.4 of the R5RS.

     `let*-values' is similar to `let-values', but the bindings are
     performed sequentially from left to right, and the region of a
     binding indicated by (formals expression) is that part of the
     `let*-values' expression to the right of the binding. Thus the
     second binding is done in an environment in which the first binding
     is visible, and so on.

          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (let*-values (((a b) (values x y))
                          ((x y) (values a b)))
              (list a b x y)))       ⇒ (x y x y)

 -- Syntax: receive formals expression body
     The formals, expression, and body are as described in R5RS.
     Specifically, formals can have any of three forms:

     `(variable1 ... variablen)'
          The environment in which the receive-expression is evaluated
          is extended by binding variable1, ..., variablen to fresh
          locations. The expression is evaluated, and its values are
          stored into those locations. (It is an error if expression
          does not have exactly n values.)

     `variable'
          The environment in which the receive-expression is evaluated
          is extended by binding variable to a fresh location. The
          expression is evaluated, its values are converted into a newly
          allocated list, and the list is stored in the location bound
          to variable.

     `(variable1 ... variablen . variablen+1)'
          The environment in which the receive-expression is evaluated
          is extended by binding variable1, ..., variablen+1 to fresh
          locations. The expression is evaluated. Its first n values are
          stored into the locations bound to variable1 ... variablen.
          Any remaining values are converted into a newly allocated
          list, which is stored into the location bound to variablen+1
          (It is an error if expression does not have at least n
          values.)

     In any case, the expressions in body are evaluated sequentially in
     the extended environment. The results of the last expression in the
     body are the values of the receive-expression.

 -- Procedure: values-append arg1 ...
     The values resulting from evaluating each argument are appended
     together.


File: kawa.info,  Node: Symbols and namespaces,  Next: Procedures,  Prev: Multiple values,  Up: Top

6 Symbols and namespaces
************************

An identifier is a name that appears in a program.

   A symbol is an object representing a string that cannot be modified.
This string is called the symbol's name. Unlike strings, two symbols
whose names are spelled the same way are indistinguishable.  A symbol is
immutable (unmodifiable) and normally viewed as atomic.  Symbols are
useful for many applications; for instance, they may be used the way
enumerated values are used in other languages.

   In addition to the simple symbols or standard Scheme, Kawa also has
compound (two-part) symbols.

* Menu:

* Simple symbols::
* Namespaces::
* Keywords::
* Special named constants::


File: kawa.info,  Node: Simple symbols,  Next: Namespaces,  Up: Symbols and namespaces

6.1 Simple symbols
==================

Simple symbols have no properties other than their name, an immutable
string.  They have the useful property that two simple symbols are
identical (in the sense of `EQ?', `EQV?' and `EQUAL?') if and only if
their names are spelled the same way.  A symbol literal is formed using
`QUOTE'.

 -- Procedure: symbol? obj
     Return `#t' if obj is a symbol, `#f' otherwise.

          (symbol? 'foo)          ⇒ #t
          (symbol? (car '(a b)))  ⇒ #t
          (symbol? "bar")         ⇒ #f
          (symbol? 'nil)          ⇒ #t
          (symbol? '())           ⇒ #f
          (symbol? #f)            ⇒ #f

 -- Procedure: symbol->string symbol
     Return the name of symbol as an immutable string.

          (symbol->string 'flying-fish)                   ⇒  "flying-fish"
          (symbol->string 'Martin)                        ⇒  "Martin"
          (symbol->string (string->symbol "Malvina"))     ⇒  "Malvina"

 -- Procedure: string->symbol string
     Return the symbol whose name is string.

          (eq? 'mISSISSIppi 'mississippi)
          ⇒ #f

          (string->symbol "mISSISSIppi")
          ⇒ the symbol with name "mISSISSIppi"

          (eq? 'bitBlt (string->symbol "bitBlt"))
          ⇒ #t

          (eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
          ⇒ #t

          (string=? "K. Harper, M.D."
                    (symbol->string (string->symbol "K. Harper, M.D.")))
          ⇒ #t


File: kawa.info,  Node: Namespaces,  Next: Keywords,  Prev: Simple symbols,  Up: Symbols and namespaces

6.2 Namespaces and compound symbols
===================================

Different applications may want to use the same symbol to mean different
things.  To avoid such "name clashes" we can use "compound symbols",
which have two string parts: a "local name" and a "namespace URI".  The
namespace-uri can be any string, but it is recommended that it have the
form of an absolute URI
(http://en.wikipedia.org/wiki/Uniform_Resource_Identifier).  It would be
too verbose to write the full URI all the time, so one usually uses a
"namespace prefix" (namespace alias) as a short local alias to refer to
a namespace URI.

   Compound symbols are usually written using the infix colon operator:
     prefix`:'local-name
   where prefix is is namespace alias bound to some (lexically-known)
namespace URI.

   Compound symbols are used for namespace-aware XML processing.

6.2.1 Namespace objects
-----------------------

A "namespace" is a mapping from strings to symbols.  The string is the
local-name of resulting symbol.  A namespace is similar to a Common Lisp
"package".

   A namespace has a namespace-uri, which a string; it recommended that
it have the form of an absolute URI.  A namespace may optionally have a
prefix, which is a string used when printing out symbols belonging to
the namespace.  (If you want for “equivalent symbols” (i.e. those that
have the same local-name and same uri) to be the identical symbol
object, then you should use namespaces whose prefix is the empty
string.)

 -- Constructor: namespace name [prefix]
     Return a namespace with the given name and prefix.  If no such
     namespace exists, create it.  The namespace-name is commonly a URI,
     especially when working with XML, in which case it is called a
     namespace-URI.  However, any non-empty string is allowed.  The
     prefix can be a string or a simple symbol.  (If a symbol is used,
     then the symbol's local-name is used.)  The default for prefix is
     the empty string.  Multiple calls with the same arguments will
     yield the same namespace object.

   The reader macro `#,namespace' is equivalent to the `namespace'
function, but it is invoked at read-time:
     #,(namespace "http://www.w3.org/1999/XSL/Transform" xsl)
     (eq? #,(namespace "foo") (namespace "foo")) ⇒ #t

   The form `(,#namespace "" "")' returns the default "empty namespace",
which is used for simple symbols.

 -- Procedure: namespace-uri namespace
     Return the namespace-uri of the argument namespace, as a string.

 -- Procedure: namespace-prefix namespace
     Return the namespace prefix of the argument namespace, as a string.

6.2.2 Compound symbols
----------------------

A compound symbol is one that belongs to a namespace other than the
default empty namespace, and (normally) has a non-empty namespace uri.
(It is possible for a symbol to belong to a non-default namespace and
have an empty namespace uri, but that is not recommended.)

 -- Constructor: symbol local-name namespace-spec
 -- Constructor: symbol local-name [uri [prefix]]
     Construct a symbol with the given local-name and namespace.  If
     namespace-spec is a namespace object, then find (or if needed
     construct) a symbol with the given local-name belonging to the
     namespace.  Multiple calls to `symbol' with the same namespace and
     local-name will yield the same symbol object.

     If uri is a string (optionally followed by a prefix), then:

          (symbol lname uri [prefix])

     is equivalent to:

          (symbol lname (namespace uri [prefix]))

     Using `#t' for the namespace-spec is equivalent to using the empty
     namespace `#,(namespace "")'.

     Using `#!null' or `#f' for the namespace-spec creates an uninterned
     symbol, which does not belong to any namespace.

 -- Procedure: symbol-local-name symbol
     Return the local name of the argument symbol, as an immutable
     string.  (The string is interned, except in the case of an
     uninterned symbol.)

 -- Procedure: symbol-prefix symbol
     Return the prefix of the argument symbol, as an immutable (and
     interned) string.

 -- Procedure: symbol-namespace-uri symbol
     Return the namespace uri of the argument symbol, as an immutable
     (and interned) string.

 -- Procedure: symbol-namespace symbol
     Return the namespace object (if any) of the argument symbol.
     Returns `#!null' if the symbol is uninterned.

 -- Procedure: symbol=? symbol1 symbol2 symbol3 …
     Return `#t' if the symbols are equivalent as symbols, i.e., if
     their local-names and namespace-uris are the same.  They may have
     different values of `symbol-prefix' and `symbol-namespace'.  If a
     symbol is uninterned (or is `#!null') then `symbol=?' returns the
     same result as `eq?'.

   Two symbols are `equal?' or `eqv?' if they're `symbol=?'.

6.2.3 Namespace aliases
-----------------------

A namespace is usually referenced using a shorter "namespace alias",
which is is a lexical definition that binds a namespace prefix to a
namespace object (and thus a namespace uri).  This allows using compound
symbols as identifiers in Scheme programs.

 -- Syntax: define-namespace name namespace-name
     Defines name as a "namespace prefix" - a lexically scoped
     "nickname" for the namespace whose full name is namespace-name,
     which should be a non-empty string literal.  It is customary for
     the string have syntactic form of an absolute URI
     (http://en.wikipedia.org/wiki/Uniform_Resource_Identifier), but any
     non-empty string is acceptable and is used without further
     interpretation.

     Any symbols in the scope of this definitions that contain a colon,
     and where the part before the colon matches the name will be
     treated as being in the package/namespace whose global unique name
     is the namespace-name.

     Has mostly the same effect as:

          (define-constant name #,(namespace namespace-name)

     However, using `define-namespace' (rather than `define-constant')
     is recommended if you want to use compound symbols as names of
     variables, especially local variables, or if you want to quote
     compound symbols.

     Note that the prefix is only visible lexically: it is not part of
     the namespace, or thus indirectly the symbols, and so is not
     available when printing the symbol.  You might consider using
     `define-xml-namespace' as an alternative.

     A namespace is similar to a Common Lisp package, and the
     namespace-name is like the name of the package.  However, a
     namespace alias belongs to the lexical scope, while a Common Lisp
     package nickname is global and belongs to the package itself.

     If the namespace-name starts with the string `"class:"', then the
     name can be used for invoking Java methods (*note Method
     operations::) and accessing fields (*note Field operations::).

     You can use a namespace as an abbreviation or renaming of a class
     name, but as a matter of style `define-alias' is preferred.

 -- Syntax: define-private-namespace name namespace-name
     Same as `define-namespace', but the prefix name is local to the
     current module.

   For example you might have a set of a geometry definitions defined
under the namespace-uri `"http://foo.org/lib/geometry"':

     (define-namespace geom "http://foo.org/lib/geometry")
     (define (geom:translate x y)
       (java.awt.geom.AffineTransform:getTranslateInstance x y))
     (define geom:zero (geom:translate 0 0))
     geom:zero
       ⇒ AffineTransform[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]

   You could have some other definitions for complex math:
     (define-namespace complex "http://foo.org/lib/math/complex")
     (define complex:zero +0+0i)

   You can use a namespace-value directly in a compound name:
     (namespace "http://foo.org/lib/geometry"):zero
       ⇒ AffineTransform[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]

   The variation `define-xml-namespace' is used for *note Creating XML
nodes::.

 -- Syntax: define-xml-namespace prefix "namespace-uri"
     Defines a namespace with prefix prefix and URI namespace-uri.  This
     is similar to `define-namespace' but with two important
     differences:

        • Every symbol in the namespace automatically maps to an
          element-constructor-type, as with  the `html' namespace.

        • The prefix is a component of the namespace object, and hence
          indirectly of any symbols belongining to the namespace.

     Thus the definition is roughly equivalent to:

          (define-constant name #,(namespace namespace-name name)

     along with an infinite set of definitions, for every possible tag:

          (define (name:tag . rest) (apply make-element 'name:tag rest))

     $ kawa --output-format xml
     #|kawa:1|# (define-xml-namespace na "Namespace1")
     #|kawa:2|# (define-xml-namespace nb "Namespace1")
     #|kawa:3|# (define xa (na:em "Info"))
     #|kawa:4|# xa
     <na:em xmlns:na="Namespace1">Info</na:em>
     #|kawa:5|# (define xb (nb:em "Info"))
     #|kawa:6|# xa
     <nb:em xmlns:nb="Namespace1">Info</nb:em>

   Note that the prefix is part of the qualified name (it is actually
part of the namespace object), and it is used when printing the tag.
Two qualified names (symbols) that have the same local-name and the same
namespace-name are considered equal, even if they have different prefix.
You can think of the prefix as annotation used when printing, but not
otherwise part of the “meaning” of a compound symbol.  They are the same
object if they also have the same prefix.  This is an important
different from traditional Lisp/Scheme symbols, but it is how XML QNames
work.
     #|kawa:7|# (instance? xb na:em)
     true
     #|kawa:8|# (eq? 'na:em 'nb:em)
     false
     #|kawa:9|# (equal? 'na:em 'nb:em)
     true
     #|kawa:10|# (eqv? 'na:em 'nb:em)
     true
   (Note that `#t' is printed as `true' when using XML formatting.)

   The predefined `html' prefix could be defined thus:
     (define-xml-namespace html "http://www.w3.org/1999/xhtml")


File: kawa.info,  Node: Keywords,  Next: Special named constants,  Prev: Namespaces,  Up: Symbols and namespaces

6.3 Keywords
============

Keywords are similar to symbols.  The main difference is that keywords
are self-evaluating and therefore do not need to be quoted in
expressions.  They are used mainly for specifying keyword arguments.

     keyword `::=' identifier`:'

   A keyword is a single token; therefore no whitespace is allowed
between the identifier and the colon (which is not considered part of
the name of the keyword).

 -- Procedure: keyword? obj
     Return `#t' if obj is a keyword, and otherwise returns `#f'.

 -- Procedure: keyword->string keyword
     Returns the name of keyword as a string.  The name does not include
     the final `#\:'.

 -- Procedure: string->keyword string
     Returns the keyword whose name is string.  (The string does not
     include a final `#\:'.)


File: kawa.info,  Node: Special named constants,  Prev: Keywords,  Up: Symbols and namespaces

6.4 Special named constants
===========================

 -- Constant: #!optional
     Special self-evaluating literal used in lambda parameter lists
     before optional parameters.

 -- Constant: #!rest
     Special self-evaluating literal used in lambda parameter lists
     before the rest parameter.

 -- Constant: #!key
     Special self-evaluating literal used in lambda parameter lists
     before keyword parameters.

 -- Constant: #!eof
     The end-of-file object.

     Note that if the Scheme reader sees this literal at top-level, it
     is returned literally.  This is indistinguishable from coming to
     the end of the input file.  If you do not want to end reading, but
     want the actual value of `#!eof', you should quote it.

 -- Constant: #!void
     The void value.  Same as `(values)'.  If this is the value of an
     expression in a read-eval-print loop, nothing is printed.

 -- Constant: #!null
     The Java `null' value.  This is not really a Scheme value, but is
     useful when interfacing to low-level Java code.


File: kawa.info,  Node: Procedures,  Next: Numbers,  Prev: Symbols and namespaces,  Up: Top

7 Procedures
************

 -- Procedure: apply proc [arg1 ...] args
     Args must be a sequence (list, vector, or string) or a primitive
     Java array.  (This is an extension over standard Scheme, which
     requires that args be a list.)  Calls the proc (which must be a
     procedure), using as arguments the arg1... values plus all the
     elements of args.

 -- Syntax: constant-fold proc arg1 ...
     Same as `(proc arg1 ...)', unless proc and all the following
     arguments are compile-time constants.  (That is:  They are either
     constant, or symbols that have a global binding and no lexical
     binding.)  In that case, proc is applied to the arguments at
     compile-time, and the result replaces the `constant-fold' form.  If
     the application raises an exception, a compile-time error is
     reported.  For example:

          (constant-fold vector 'a 'b 'c)

     is equivalent to `(quote #(a b c))', assuming `vector' has not been
     re-bound.

* Menu:

* Procedure properties::
* Generic procedures::
* Extended formals::


File: kawa.info,  Node: Procedure properties,  Next: Generic procedures,  Up: Procedures

7.1 Procedure properties
========================

You can associate arbitrary "properties" with any procedure.  Each
property is a (key, value)-pair.  Usually the key is a symbol, but it
can be any object.

   The system uses certain internal properties: `'name' refers to the
name used when a procedure is printed; `'emacs-interactive' is used to
implement Emacs `interactive' specification; `'setter' is used to
associate a `setter' prcedure.

 -- Procedure: procedure-property proc key [default]
     Get the property value corresponding to the given key.  If proc has
     no property with the given key, return default (which defaults to
     `#f') instead.

 -- Procedure: set-procedure-property! proc key value
     Associate the given value with the key property of proc.

   To change the print name of the standard `+' procedure (probably not
a good idea!), you could do:
     (set-procedure-property! + 'name 'PLUS)
   Note this _only_ changes the name property used for printing:
     + ⇒ #<procedure PLUS>
     (+ 2 3) ⇒ 5
     (PLUS 3 4) ⇒ ERROR

   As a matter of style, it is cleaner to use the `define-procedure'
form, as it is a more declarative interface.

 -- Syntax: define-procedure name [propname: propvalue] ... method ...
     Defines name as a compound procedure consisting of the specified
     methods, with the associated properties.  Applying name select the
     "best" method, and applies that.  See the following section on
     generic procedures.

     For example, the standard `vector-ref' procedure specifies one
     method, as well as the `setter' property:

          (define-procedure vector-ref
            setter: vector-set!
            (lambda ((vector :: <vector>) (k :: <int>))
              (invoke vector 'get k)))


File: kawa.info,  Node: Generic procedures,  Next: Extended formals,  Prev: Procedure properties,  Up: Procedures

7.2 Generic (dynamically overloaded) procedures
===============================================

A "generic procedure" is a collection of "method procedures".  (A
"method procedure" is not the same as a Java method, but the terms are
related.)  You can call a generic procedure, which selects the "closest
match" among the component method procedures:  I.e. the most specific
method procedure that is applicable given the actual arguments.

     *Warning:* The current implementation of selecting the "best"
     method is not reliable if there is more than one method.  It can
     select depending on argument count, and it can select between
     primitive Java methods.  However, selecting between different
     Scheme procedures based on parameter types should be considered
     experimental.  The main problem is we can't determine the most
     specific method, so Kawa just tries the methods in order.

 -- Procedure: make-procedure [keyword: value]... method...
     Create a generic procedure given the specific methods.  You can
     also specify property values for the result.

     The keywords specify how the arguments are used.  A `method:'
     keyword is optional and specifies that the following argument is a
     method.  A `name:' keyword specifies the name of the resulting
     procedure, when used for printing.  Unrecognized keywords are used
     to set the procedure properties of the result.

          (define plus10 (make-procedure foo: 33 name: 'Plus10
                                      method: (lambda (x y) (+ x y 10))
                                      method: (lambda () 10)))


File: kawa.info,  Node: Extended formals,  Prev: Generic procedures,  Up: Procedures

7.3 Extended Formal Arguments List
==================================

The formal arguments list of a lambda expression has two extendsions
over standard Scheme: Kawa borrows the extended formal argument list of
DSSSL, and Kawa allows you to declare the type of the parameter.

     lambda-expression `::=' `(lambda' formals [rtype] body`)'
   where
     formals `::=' `('formal-arguments`)' | rest-arg
   You can of course also use the extended format in a `define':
     (define (name formal-arguments) [rtype] body)
     formal-arguments `::='
         req-opt-args (rest-key-args | `.' rest-arg)
     req-opt-args `::=' req-arg ... [`#!optional' opt-arg ...]
     rest-key-args `::=' [`#!rest' rest-arg] [`#!key' key-arg ...]
     req-arg `::='  variable [`::' type] | `('variable [[`::'] type] `)'
     opt-arg `::=' arg-with-default
     key-arg `::=' arg-with-default
     arg-with-default `::=' variable [`::' type]
         | `(' variable [`::' type [initializer] | initializer [[`::'] type]] `)'
     rest-arg `::=' variable

   When the procedure is applied to a list of actual arguments, the
formal and actual arguments are processed from left to right as follows:

   • The req-args are bound to actual arguments starting with the first
     actual argument.  It shall be an error if there are fewer actual
     arguments then there are req-args.

   • Next the opt-args are bound to remaining actual arguemnts.  If
     there are fewer remaining actual arguments than there are opt-args,
     then the remaining variables are bound to the corresponding
     initializer, if one was specified, and otherwise to `#f'.  The
     initializer is evaluated in an environment in which all the
     previous formal parameters have been bound.

   • If there is a rest-arg, it is bound to a list of all the remaining
     actual arguments.  These remaining actual arguments are also
     eligible to be bound to keyword arguments.   If there is no
     rest-arg and there are no key-args, then it shall be an error if
     there are any remaining actual arguments.

   • If `#!key' was specified, then there shall be an even number of
     remaining actual arguments.  These are interpreted as a series of
     pairs, where the first member of each pair is a keyword specifying
     the argument name, and the second is the corresponding value.  It
     shall be an error if the first member of a pair is not a keyword.
     It shall be an error if the argument name is not the same as a
     variable in a key-args, unless there is a rest-arg.  If the same
     argument name occurs more than once in the list of actual
     arguments, then the first value is used.  If there is no actual
     argument for a particular key-arg, then the variable is bound to
     the corresponding initializer, if one was specified, and otherwise
     to `#f'.  The initializer is evaluated in an environment in which
     all the previous formal parameters have been bound.

   If a type is specified, the corresponding actual argument (or the
initializer default value) is coerced to the specified type.  In the
function body, the parameter has the specified type.

   If rtype (the first form of the function body) is an unbound
identifier of the form `<TYPE>' (that is the first character is `<' and
the last is `>'), then that specifies the function's return type.  It is
syntactic sugar for `(as <TYPE> (begin BODY))'.

 -- Syntax: cut slot-or-expr slot-or-expr* [`<...>']
     where each slot-or-expr is either an expression or the literal
     symbol `<>'.

     It is frequently necessary to specialize some of the parameters of
     a multi-parameter procedure. For example, from the binary operation
     `cons' one might want to obtain the unary operation `(lambda (x)
     (cons 1 x))'.  This specialization of parameters is also known as
     "partial application", "operator section", or "projection".  The
     macro `cut' specializes some of the parameters of its first
     argument. The parameters that are to show up as formal variables of
     the result are indicated by the symbol `<>', pronouced as "slot".
     In addition, the symbol `<...>', pronounced as "rest-slot", matches
     all residual arguments of a variable argument procedure.

     A `cut'-expression is transformed into a lambda expression with as
     many formal variables as there are slots in the list slot-or-expr*.
     The body of the resulting lambda expression calls the first
     slot-or-expr with arguments from the slot-or-expr* list in the
     order they appear. In case there is a rest-slot symbol, the
     resulting procedure is also of variable arity, and the body calls
     the first slot-or-expr with remaining arguments provided to the
     actual call of the specialized procedure.

     Here are some examples:

     `(cut cons (+ a 1) <>)' is the same as
     `(lambda (x2) (cons (+ a 1) x2))'

     `(cut list 1 <> 3 <> 5)' is the same as
     `(lambda (x2 x4) (list 1 x2 3 x4 5))'

     `(cut list)' is the same as `(lambda () (list))'

     `(cut list 1 <> 3 <...>)' is the same as
     `(lambda (x2 . xs) (apply list 1 x2 3 xs))'

     The first argument can also be a slot, as one should expect in
     Scheme: `(cut <> a b)' is the same as `(lambda (f) (f a b))'

 -- Syntax: cute slot-or-expr slot-or-expr* [`<...>']
     The macro `cute' (a mnemonic for "cut with evaluated non-slots") is
     similar to `cut', but it evaluates the non-slot expressions at the
     time the procedure is specialized, not at the time the specialized
     procedure is called.

     For example `(cute cons (+ a 1) <>)' is the same as
     `(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))'

     As you see from comparing this example with the first example
     above, the `cute'-variant will evaluate `(+ a 1)' once, while the
     `cut'-variant will evaluate it during every invocation of the
     resulting procedure.


File: kawa.info,  Node: Numbers,  Next: Characters and text,  Prev: Procedures,  Up: Top

8 Quantities and Numbers
************************

Kawa supports the full Scheme set of number operations with some
extensions.

   Kawa converts between Scheme number types and Java number types as
appropriate.

* Menu:

* Arithmetic operations::
* Quantities::
* Logical Number Operations::
* Performance of numeric operations::


File: kawa.info,  Node: Arithmetic operations,  Next: Quantities,  Up: Numbers

8.1 Arithmetic operations
=========================

 -- Procedure: + z …
 -- Procedure: * z …
     These procedures return the sum or product of their arguments.

          (+ 3 4)                          ⇒  7
          (+ 3)                            ⇒  3
          (+)                              ⇒  0
          (+ +inf.0 +inf.0)                ⇒  +inf.0
          (+ +inf.0 -inf.0)                ⇒  +nan.0

          (* 4)                            ⇒  4
          (*)                              ⇒  1
          (* 5 +inf.0)                     ⇒  +inf.0
          (* -5 +inf.0)                    ⇒  -inf.0
          (* +inf.0 +inf.0)                ⇒  +inf.0
          (* +inf.0 -inf.0)                ⇒  -inf.0
          (* 0 +inf.0)                     ⇒  +nan.0
          (* 0 +nan.0)                     ⇒  +nan.0
          (* 1.0 0)                        ⇒  0.0

     For any real number object x that is neither infinite nor NaN:

          (+ +inf.0 x)                   ⇒  +inf.0
          (+ -inf.0 x)                   ⇒  -inf.0

     For any real number object x:

          (+ +nan.0 x)                   ⇒  +nan.0

     For any real number object x that is not an exact 0:

          (* +nan.0 x)                   ⇒  +nan.0

     The behavior of `-0.0' is illustrated by the following examples:

          (+  0.0 -0.0)  ⇒  0.0
          (+ -0.0  0.0)  ⇒  0.0
          (+  0.0  0.0)  ⇒  0.0
          (+ -0.0 -0.0)  ⇒ -0.0

 -- Procedure: - z
 -- Procedure: - z1 z2 z3 …
     With two or more arguments, this procedures returns the difference
     of its arguments, associating to the left.  With one argument,
     however, it returns the negation (additive inverse) of its
     argument.

          (- 3 4)                               ⇒  -1
          (- 3 4 5)                             ⇒  -6
          (- 3)                                 ⇒  -3
          (- +inf.0 +inf.0)                     ⇒  +nan.0

     The behavior of `-0.0' is illustrated by the following examples:

          (-  0.0)       ⇒ -0.0
          (- -0.0)       ⇒  0.0
          (-  0.0 -0.0)  ⇒  0.0
          (- -0.0  0.0)  ⇒ -0.0
          (-  0.0  0.0)  ⇒  0.0
          (- -0.0 -0.0)  ⇒  0.0

 -- Procedure: / z
 -- Procedure: / z1 z2 z3 …
     If all of the arguments are exact, then the divisors must all be
     nonzero.  With two or more arguments, this procedure returns the
     quotient of its arguments, associating to the left.  With one
     argument, however, it returns the multiplicative inverse of its
     argument.

          (/ 3 4 5)                         ⇒  3/20
          (/ 3)                             ⇒  1/3
          (/ 0.0)                           ⇒  +inf.0
          (/ 1.0 0)                         ⇒  +inf.0
          (/ -1 0.0)                        ⇒  -inf.0
          (/ +inf.0)                        ⇒  0.0
          (/ 0 0)                           ⇒  exception &assertion
          (/ 3 0)                           ⇒  exception &assertion
          (/ 0 3.5)                         ⇒  0.0
          (/ 0 0.0)                         ⇒  +nan.0
          (/ 0.0 0)                         ⇒  +nan.0
          (/ 0.0 0.0)                       ⇒  +nan.0

     If this procedure is applied to mixed non–rational real and
     non–real complex arguments, it either raises an exception with
     condition type `&implementation-restriction' or returns an
     unspecified number object.

 -- Procedure: div x1 x2
 -- Procedure: mod x1 x2
 -- Procedure: div-and-mod x1 x2
     These procedures implement number–theoretic integer division.  They
     accept two real numbers x1 and x2 as operands, where x2 must be
     nonzero.  (Kawa allows x2 to be zero for `mod'.)  `div' returns an
     integer, and `mod' returns a real.  Their results are specified by:

          (div x1 x2) ⇒ nd
          (mod x1 x2) ⇒ xm

     such that:

          x1 = nd * x2 + xm
          0  <= xm < |x2|

          (div-and-mod x1 x2)
            ⇒ (values (div x1 x2) (mod x1 x2))

          (div 123 10)    ⇒  12
          (mod 123 10)    ⇒  3
          (div 123 -10)   ⇒  -12
          (mod 123 -10)   ⇒  3
          (div -123 10)   ⇒  -13
          (mod -123 10)   ⇒  7
          (div -123 -10)  ⇒  13
          (mod -123 -10)  ⇒  7
          (mod 123 0)     ⇒  123 ;; Kawa extension

 -- Procedure: div0 x1 x2
 -- Procedure: mod0 x1 x2
 -- Procedure: div0-and-mod0 x1 x2
     `div0' and `mod0' are like `div' and `mod', except the result of
     `mod0' lies within a half–open interval centered on zero.  The
     results are specified by:

          (div0 x1 x2) ⇒ nd
          (mod0 x1 x2) ⇒ xm

     such that:

          x1 = nd * x2 + xm
          -|x2| <= xm < |x2/2|

          (div0-and-mod0 x1 x2)
            ⇒ (values (div0 x1 x2) (mod0 x1 x2))

          (div0 123 10)   ⇒  12
          (mod0 123 10)   ⇒  3
          (div0 123 -10)  ⇒  -12
          (mod0 123 -10)  ⇒  3
          (div0 -123 10)  ⇒  -12
          (mod0 -123 10)  ⇒  -3
          (div0 -123 -10) ⇒  12
          (mod0 -123 -10) ⇒  -3

 -- Procedure: quotient x y
     Kawa generalizes `quotient' to arbitrary real numbers, using the
     definition: `(truncate (/ x y))'.

 -- Procedure: remainder x y
     Generalized to arbitrary real numbers, using the definition: `(- x
     (* y (truncate (/ x y))))'.  If `y' is `0', the result is `x' -
     i.e. we take `(* 0 (quotient x 0))' to be `0'.  The result is
     inexact if either argument is inexact, even if `x' is exact and `y'
     is 0.

          (remainder 13 4)     ⇒ 1
          (remainder -13 4)    ⇒ -1
          (remainder 13 -4)    ⇒ 1
          (remainder -13 -4)   ⇒ -1
          (remainder -13 -4.0) ⇒ -1.0

 -- Procedure: modulo x y
     Generalized to arbitrary real numbers, using the definition: `(- x
     (* y (floor (/ x y))))'.  If `y' is `0', the result is `x'.  The
     result is inexact if either argument is inexact, even if `x' is
     exact and `y' is 0.

          (modulo 13 4)   ⇒ 1
          (modulo -13 4)  ⇒ 3
          (modulo 13 -4)  ⇒ -4
          (modulo -13 -4) ⇒ -1

 -- Procedure: abs x
     Returns the absolute value of its argument.

          (abs -7)                         ⇒  7
          (abs -inf.0)                     ⇒  +inf.0

 -- Procedure: gcd n1 …
 -- Procedure: lcm n1 …
     These procedures return the greatest common divisor or least common
     multiple of their arguments.  The result is always non–negative.
     (R6RS allows inexact integer arguments; Kawa does not.)

          (gcd 32 -36)                     ⇒  4
          (gcd)                            ⇒  0
          (lcm 32 -36)                     ⇒  288
          (lcm 32.0 -36)                   ⇒  288.0
          (lcm)                            ⇒  1

 -- Procedure: numerator q
 -- Procedure: denominator q
     These procedures return the numerator or denominator of their
     argument; the result is computed as if the argument was represented
     as a fraction in lowest terms.  The denominator is always positive.
     The denominator of `0' is defined to be `1'.  (R6RS allows inexact
     integer arguments; Kawa does not.)

          (numerator   (/ 6 4))            ⇒  3
          (denominator (/ 6 4))            ⇒  2

 -- Procedure: floor x
 -- Procedure: ceiling x
 -- Procedure: truncate x
 -- Procedure: round x
     These procedures return inexact integer objects for inexact
     arguments that are not infinities or NaNs, and exact integer
     objects for exact rational arguments.

     `floor'
          Returns the largest integer object not larger than x.

     `ceiling'
          Returns the smallest integer object not smaller than x.

     `truncate'
          Returns the integer object closest to x whose absolute value
          is not larger than the absolute value of x.

     `round'
          Returns the closest integer object to x, rounding to even when
          x represents a number halfway between two integers.

     If the argument to one of these procedures is inexact, then the
     result is also inexact.  If an exact value is needed, the result
     should be passed to the `EXACT' procedure.

     Although infinities and NaNs are not integer objects, these
     procedures return an infinity when given an infinity as an
     argument, and a NaN when given a NaN.

          (floor -4.3)                     ⇒  -5.0
          (ceiling -4.3)                   ⇒  -4.0
          (truncate -4.3)                  ⇒  -4.0
          (round -4.3)                     ⇒  -4.0

          (floor 3.5)                      ⇒  3.0
          (ceiling 3.5)                    ⇒  4.0
          (truncate 3.5)                   ⇒  3.0
          (round 3.5)                      ⇒  4.0

          (round 7/2)                      ⇒  4
          (round 7)                        ⇒  7

          (floor +inf.0)                   ⇒  +inf.0
          (ceiling -inf.0)                 ⇒  -inf.0
          (round +nan.0)                   ⇒  +nan.0

 -- Procedure: rationalize x1 x2
     The `RATIONALIZE' procedure returns a number object representing
     the _simplest_ rational number differing from x1 by no more than
     x2.

     A rational number _r_1_ is _simpler_ than another rational number
     _r_2_ if `r_1 = p_1/q_1' and `r_2 = p_2/q_2' (in lowest terms) and
     `|p_1| <= |p_2|' and `|q_1| <= |q_2|'.  Thus `3/5' is simpler than
     `4/7'.

     Although not all rationals are comparable in this ordering
     (consider `2/7' and `3/5') any interval contains a rational number
     that is simpler than every other rational number in that interval
     (the simpler `2/5' lies between `2/7' and `3/5').

     Note that `0 = 0/1' is the simplest rational of all.

          (rationalize (exact .3) 1/10)          => 1/3
          (rationalize .3 1/10)                  => #i1/3  ; approximately

          (rationalize +inf.0 3)                 =>  +inf.0
          (rationalize +inf.0 +inf.0)            =>  +nan.0

     The first two examples hold only in implementations whose inexact
     real number objects have sufficient precision.

 -- Procedure: exp z
 -- Procedure: log z
 -- Procedure: log z1 z2
 -- Procedure: sin z
 -- Procedure: cos z
 -- Procedure: tan z
 -- Procedure: asin z
 -- Procedure: acos z
 -- Procedure: atan z
 -- Procedure: atan x1 x2
     These procedures compute the usual transcendental functions.

     The `EXP' procedure computes the base–e exponential of z.  The
     `LOG' procedure with a single argument computes the natural
     logarithm of z (*not* the base–10 logarithm); `(log z1 z2)'
     computes the base–z2 logarithm of z1.

     The `ASIN', `ACOS', and `ATAN' procedures compute arcsine,
     arccosine, and arctangent, respectively.  The two–argument variant
     of `ATAN' computes:

          (angle (make-rectangular x2 x1))

     These procedures may return inexact results even when given exact
     arguments.

          (exp +inf.0)    ⇒ +inf.0
          (exp -inf.0)    ⇒ 0.0
          (log +inf.0)    ⇒ +inf.0
          (log 0.0)       ⇒ -inf.0
          (log 0)         ⇒ exception &assertion
          (log -inf.0)    ⇒ +inf.0+3.141592653589793i    ; approximately
          (atan -inf.0)   ⇒ -1.5707963267948965          ; approximately
          (atan +inf.0)   ⇒ 1.5707963267948965           ; approximately
          (log -1.0+0.0i) ⇒ 0.0+3.141592653589793i       ; approximately
          (log -1.0-0.0i) ⇒ 0.0-3.141592653589793i       ; approximately
                                                          ; if -0.0 is distinguished

 -- Procedure: sqrt z
     Return the principal square root of z.  For rational z, the result
     has either positive real part, or zero real part and non–negative
     imaginary part.  The value of `(sqrt z)' could be expressed as:

          e^((log z)/2)

     The `SQRT' procedure may return an inexact result even when given
     an exact argument.

          (sqrt -5)                   ⇒  0.0+2.23606797749979i ; approximately
          (sqrt +inf.0)               ⇒  +inf.0
          (sqrt -inf.0)               ⇒  +inf.0i


File: kawa.info,  Node: Quantities,  Next: Logical Number Operations,  Prev: Arithmetic operations,  Up: Numbers

8.2 Quantities and Units
========================

As a super-class of numbers, Kawa also provides quantities.  A
"quantity" is a product of a "unit" and a pure number.  The number part
can be an arbitrary complex number.  The unit is a product of integer
powers of base units, such as meter or second.

   Kawa quantities are a generalization of the quantities in DSSSL,
which only has length-derived quantities.

   The precise syntax of quantity literals may change, but some examples
are `10pt' (10 points), `5s' (5 seconds), and `4cm^2' (4 square
centimeters).

 -- Procedure: quantity? object
     True iff object is a quantity.  Note that all numbers are
     quantities, but not the other way round.  Currently, there are no
     quantities that re not numbers.  To distinguish a plain unit-less
     number from a quantity, you can use `complex?'.

 -- Procedure: quantity->number q
     Returns the pure number part of the quantity q, relative to
     primitive (base) units.  If q is a number, returns q.  If q is a
     unit, yields the magitude of q relative to base units.

 -- Procedure: quantity->unit q
     Returns the unit of the quantity q.  If q is a number, returns the
     empty unit.

 -- Procedure: make-quantity x unit
     Returns the product of x (a pure number) and unit.  You can specify
     a string instead of unit, such as `"cm"' or `"s"' (seconds).

 -- Syntax: define-base-unit unit-name dimension
     Define unit-name as a base (primitive) unit, which is used to
     measure along the specified dimension.

          (define-base-unit dollar "Money")

 -- Syntax: define-unit unit-name expression
     Define unit-name as a unit (that can be used in literals) equal to
     the quantity expression.

          (define-unit cent 0.01dollar)

     The unit-name is declared in the `unit' namespace, so the above is
     equivalent to:

          (define-constant unit:cent (* 0.01 unit:dollar))


File: kawa.info,  Node: Logical Number Operations,  Next: Performance of numeric operations,  Prev: Quantities,  Up: Numbers

8.3 Logical Number Operations
=============================

These functions operate on the 2's complement binary representation of
an exact integer.

 -- Procedure: bitwise-not i
     Returns the bit-wise logical inverse of the argument.  More
     formally, returns the exact integer whose two's complement
     representation is the one's complement of the two's complement
     representation of i.

 -- Procedure: bitwise-and i ...
 -- Procedure: bitwise-ior i ...
 -- Procedure: bitwise-xor i ...
     These procedures return the exact integer that is the bit-wise
     “and”, “inclusive or”, or “exclusive or” of the two's complement
     representations of their arguments.  If they are passed only one
     argument, they return that argument.  If they are passed no
     arguments, they return the integer that acts as identity for the
     operation: -1, 0, or 0, respectively.

 -- Procedure: bitwise-if i1 i2 i3
     Returns the exact integer that is the bit-wise “if” of the twos
     complement representations of its arguments, i.e. for each bit, if
     it is 1 in i1, the corresponding bit in i2 becomes the value of the
     corresponding bit in the result, and if it is 0, the corresponding
     bit in i3 becomes the corresponding bit in the value of the result.
     This is equivaent to the following computation:

          (bitwise-ior (bitwise-and i1 i2)
                       (bitwise-and (bitwise-not i1) i3))

 -- Procedure: bitwise-bit-count i
     If ei is non-negative, returns the number of 1 bits in the twos
     complement representation of i. Otherwise it returns the result of
     the following computation:

          (bitwise-not (bitwise-bit-count (bitwise-not i)))

 -- Procedure: bitwise-length i
     Returns the number of bits needed to represent i if it is positive,
     and the number of bits needed to represent `(bitwise-not i)' if it
     is negative, which is the exact integer that is the result of the
     following computation:

          (do ((result 0 (+ result 1))
               (bits (if (negative? i)
                         (bitwise-not i)
                         ei)
                     (bitwise-arithmetic-shift bits -1)))
              ((zero? bits)
               result))

     This is the number of bits needed to represent i in an unsigned
     field.

 -- Procedure: bitwise-first-bit-set i
     Returns the index of the least significant 1 bit in the twos
     complement representation of i. If ei is 0, then - 1 is returned.

          (bitwise-first-bit-set 0) ⇒ -1
          (bitwise-first-bit-set 1) ⇒ 0
          (bitwise-first-bit-set -4) ⇒ 2

 -- Procedure: bitwise-bit-set? i1 i2
     Returns `#t' if the i2'th bit (where i2 must be non-negative) is 1
     in the two's complement representation of i1, and `#f' otherwise.
     This is the result of the following computation:

          (not (zero?
                 (bitwise-and
                   (bitwise-arithmetic-shift-left 1 i2)
                   i1)))

 -- Procedure: bitwise-copy-bit i bitno replacement-bit
     Return the result of replacing the bitno'th bit of i by
     replacement-bit, where bitno must be non-negative, and
     replacement-bit must be either 0 or 1.  This is the result of the
     following computation:

          (let* ((mask (bitwise-arithmetic-shift-left 1 bitno)))
            (bitwise-if mask
                      (bitwise-arithmetic-shift-left replacement-bit bitno)
                      i))

 -- Procedure: bitwise-bit-field n start end
     Return the integer formed from the (unsigned) bit-field starting at
     start and ending just before end.  Same as:

          (let ((mask
                 (bitwise-not
                  (bitwise-arithmetic-shift-left -1 end))))
            (bitwise-arithmetic-shift-right
              (bitwise-and n mask)
              start))

 -- Procedure: bitwise-copy-bit-field to start end from
     Returns the result of replacing in to the bits at positions from
     start (inclusive) to end (exclusive) by the bits in from from
     position 0 (inclusive) to position end - start (exclusive).  Both
     start and start must be non-negative, and start must be less than
     or equal to start.

     This is the result of the following computation:

          (let* ((mask1
                   (bitwise-arithmetic-shift-left -1 start))
                 (mask2
                   (bitwise-not
                     (bitwise-arithmetic-shift-left -1 end)))
                 (mask (bitwise-and mask1 mask2)))
            (bitwise-if mask
                        (bitwise-arithmetic-shift-left from
                                                       start)
                        to))

 -- Procedure: bitwise-arithmetic-shift i j
     Shifts i by j.  It is a “left” shift if `j>0', and a “right” shift
     if `j<0'.  The result is equal to `(floor (* i (expt 2 j)))'.

     Examples:

          (bitwise-arithmetic-shift -6 -1) ⇒-3
          (bitwise-arithmetic-shift -5 -1) ⇒ -3
          (bitwise-arithmetic-shift -4 -1) ⇒ -2
          (bitwise-arithmetic-shift -3 -1) ⇒ -2
          (bitwise-arithmetic-shift -2 -1) ⇒ -1
          (bitwise-arithmetic-shift -1 -1) ⇒ -1

 -- Procedure: bitwise-arithmetic-shift-left i amount
 -- Procedure: bitwise-arithmetic-shift-right i amount
     The amount must be non-negative The `bitwise-arithmetic-shift-left'
     procedure returns the same result as `bitwise-arithmetic-shift',
     and `(bitwise-arithmetic-shift-right i amount)' returns the same
     result as `(bitwise-arithmetic-shift i (- amount))';

 -- Procedure: bitwise-rotate-bit-field n start end count
     Returns the result of cyclically permuting in n the bits at
     positions from start (inclusive) to end (exclusive) by count bits
     towards the more significant bits, start and end must be
     non-negative, and start must be less than or equal to end.  This is
     the result of the following computation:

          (let* ((n     ei1)
                 (width (- end start)))
            (if (positive? width)
                (let* ((count (mod count width))
                       (field0
                         (bitwise-bit-field n start end))
                       (field1 (bitwise-arithmetic-shift-left
                                 field0 count))
                       (field2 (bitwise-arithmetic-shift-right
                                 field0
                                 (- width count)))
                       (field (bitwise-ior field1 field2)))
                  (bitwise-copy-bit-field n start end field))
                n))

 -- Procedure: bitwise-reverse-bit-field i start end
     Returns the result obtained from i by reversing the order of the
     bits at positions from start (inclusive) to end (exclusive), where
     start and end must be non-negative, and start must be less than or
     equal to end.

          (bitwise-reverse-bit-field #b1010010 1 4) ⇒  88 ; #b1011000

 -- Procedure: logop op x y
     Perform one of the 16 bitwise operations of x and y, depending on
     op.

 -- Procedure: logtest i j
     Returns true if the arguments have any bits in common.  Same as
     `(not (zero? (bitwise-and i j)))', but is more efficient.

8.3.1 Deprecated Logical Number Operations
------------------------------------------

These older functions are still available, but we recommand using the
R6RS-compatible functions.

 -- Procedure: lognot i
     Equivalent to `(bitwise-not i)'.

 -- Procedure: logand i ...
     Equivalent to `(bitwise-and i ...)'.

 -- Procedure: logior i ...
     Equivalent to `(bitwise-ior i ...)'.

 -- Procedure: logxor i ...
     Equivalent to `(bitwise-xor i ...)'.

 -- Procedure: logcount i
     Count the number of 1-bits in i, if it is non-negative.  If i is
     negative, count number of 0-bits.  Same as `(bitwise-bit-count i)'
     if i is non-negative.

 -- Procedure: integer-length i
     Equivalent to `(bitwise-length i)'.

 -- Procedure: logbit? i pos
     Equivalent to `bitwise-bit-set? i pos)'.

 -- Procedure: arithmetic-shift i j
     Equivalent to `bitwise-arithmetic-shift i j)'.

 -- Procedure: ash i j
     Alias for `arithmetic-shift'.

 -- Procedure: bit-extract n start end
     Equivalent to `(bitwise-bit-field n start end)'.


File: kawa.info,  Node: Performance of numeric operations,  Prev: Logical Number Operations,  Up: Numbers

8.4 Performance of numeric operations
=====================================

Kawa can generally do a pretty good job of generating efficient code for
numeric operations, at least when it knows or can figure out the types
of the operands.

   The basic operations `+', `-', and `*' are compiled to
single-instruction bytecode if both operands are `int' or `long'.
Likewise, if both operands are floating-point (or one is floating-point
and the other is rational), then single-instruction `double' or `float'
instructions are emitted.

   A binary operation involing an infinite-precision `integer' and a
fixed-size `int' or `long' is normally evaluated by expanding the latter
to `integer' and using `integer' arithmetic.  An exception is the
`integer' argument is an integer literal whose value fits in a `int' or
`long' - in that case the operation is done using  `int' or `long'
arithmetic.

   In general, integer literals have amorphous type.  When used to infer
the type of a variable, they have `integer' type:
     (let ((v1 0))
       ... v1 has type integer ... )
   However, a literal whose value fits in the `int' or `long' range is
implicitly viewed `int' or `long' in certain contexts, primarily method
overload resolution and binary arithmethic (as mentioned above).

   The comparison functions `<', `<=', `=', `>', and `=>' are also
optimized to single instriction operations if the operands have
appropriate type.  However, the functions `zero?', `positive?', and
`negative?' have not yet been optimized.  Instead of `(positive? x)'
write `(> x 0)'.

   There are a number of integer division and modulo operations.  If the
operands are `int' or `long', it is faster to use `quotient' and
`remainder' rather than `div' and `mod' (or `modulo').  If you know the
first operand is non-negative and the second is positive, then use
`quotient' and `remainder'.  (If an operand is an arbitrary-precision
`integer', then it dosn't really matter.)

   The logical operations `bitwise-and', `bitwise-ior', `bitwise-xor',
`bitwise-not', `bitwise-arithmetic-shift-left',
`bitwise-arithmetic-shift-right' are compiled to single bitcode
instructions if the operands are `int' or `long'.  Avoid
`bitwise-arithmetic-shift' if the sign of the shift is known.  If the
operands are arbitrary-precision `integer', a library call is needed,
but run-time type dispatch is avoided.


File: kawa.info,  Node: Characters and text,  Next: Data structures,  Prev: Numbers,  Up: Top

9 Characters and text
*********************

* Menu:

* Characters::
* Strings::
* Unicode::              Unicode character classes and conversions
* Regular expressions::


File: kawa.info,  Node: Characters,  Next: Strings,  Up: Characters and text

9.1 Characters
==============

_Characters_ are objects that represent Unicode scalar values.

     _Note:_ Unicode defines a standard mapping between sequences of
     "Unicode scalar values"  (integers in the range `0' to `#x10FFFF',
     excluding the range `#xD800' to `#xDFFF') in the latest version of
     the standard and human–readable “characters”.  More precisely,
     Unicode distinguishes between glyphs, which are printed for humans
     to read, and characters, which are abstract entities that map to
     glyphs (sometimes in a way that’s sensitive to surrounding
     characters). Furthermore, different sequences of scalar values
     sometimes correspond to the same character. The relationships among
     scalar, characters, and glyphs are subtle and complex.

     Despite this complexity, most things that a literate human would
     call a “character” can be represented by a single Unicode scalar
     value (although several sequences of Unicode scalar values may
     represent that same character). For example, Roman letters,
     Cyrillic letters, Hebrew consonants, and most Chinese characters
     fall into this category.

     Unicode scalar values exclude the range `#xD800' to `#xDFFF', which
     are part of the range of Unicode "code points".  However, the
     Unicode code points in this range, the so-called "surrogates", are
     an artifact of the UTF-16 encoding, and can only appear in specific
     Unicode encodings, and even then only in pairs that encode scalar
     values.  Consequently, all characters represent code points, but
     the surrogate code points do not have representations as
     characters.

 -- Procedure: char? obj
     Return `#t' if obj is a character, `#f' otherwise.

 -- Procedure: char->integer char
 -- Procedure: integer->char sv
     sv must be a Unicode scalar value, i.e., a non–negative exact
     integer object in `[0, #xD7FF] union [#xE000, #x10FFFF]'.

     Given a character, `CHAR->INTEGER' returns its Unicode scalar value
     as an exact integer object.  For a Unicode scalar value sv,
     `INTEGER->CHAR' returns its associated character.

          (integer->char 32)                     ⇒ #\space
          (char->integer (integer->char 5000))   ⇒ 5000
          (integer->char #\xD800)                ⇒ throws ClassCastException

 -- Procedure: char=? char1 char2 char3 …
 -- Procedure: char<? char1 char2 char3 …
 -- Procedure: char>? char1 char2 char3 …
 -- Procedure: char<=? char1 char2 char3 …
 -- Procedure: char>=? char1 char2 char3 …
     These procedures impose a total ordering on the set of characters
     according to their Unicode scalar values.

          (char<? #\z #\ß)      ⇒ #t
          (char<? #\z #\Z)      ⇒ #f


File: kawa.info,  Node: Strings,  Next: Unicode,  Prev: Characters,  Up: Characters and text

9.2 Strings
===========

Strings are sequences of characters.  The _length_ of a string is the
number of characters that it contains.  This number is fixed when the
string is created.  The _valid indices_ of a string are the integers
less than the length of the string.  The first character of a string has
index 0, the second has index 1, and so on.

     _Kawa note:_ Kawa's implementation of strings that contain
     surrogate characters does not quite follow the R6RS specification.
     Specifically indexing into such a string retrieves a surrogate
     rather than a Unicode scalar value.  It is not clear what the best
     solution is - there is a tradeoff between performance,
     compatibility with R6RS, and interoperability with Java APIs.

 -- Procedure: string? obj
     Return `#t' if obj is a string, `#f' otherwise.

 -- Procedure: make-string k
 -- Procedure: make-string k char
     Return a newly allocated string of length k.  If char is given,
     then all elements of the string are initialized to char, otherwise
     the contents of the string are unspecified.

 -- Procedure: string char …
     Return a newly allocated string composed of the arguments.

 -- Procedure: string-length string
     Return the number of characters in the given string as an exact
     integer object.

 -- Procedure: string-ref string k
     k must be a valid index of string.  The `STRING-REF' procedure
     returns character k of string using zero–origin indexing.

     time.

 -- Procedure: string=? string1 string2 string3 …
     Return `#t' if the strings are the same length and contain the same
     characters in the same positions.  Otherwise, the `STRING=?'
     procedure returns `#f'.

          (string=? "Straße" "Strasse")    ⇒ #f

 -- Procedure: string<? string1 string2 string3 …
 -- Procedure: string>? string1 string2 string3 …
 -- Procedure: string<=? string1 string2 string3 …
 -- Procedure: string>=? string1 string2 string3 …
     These procedures are the lexicographic extensions to strings of the
     corresponding orderings on characters.  For example, `STRING<?' is
     the lexicographic ordering on strings induced by the ordering
     `CHAR<?' on characters.  If two strings differ in length but are
     the same up to the length of the shorter string, the shorter string
     is considered to be lexicographically less than the longer string.

          (string<? "z" "ß")      ⇒ #t
          (string<? "z" "zz")     ⇒ #t
          (string<? "z" "Z")      ⇒ #f

 -- Procedure: substring string start end
     string must be a string, and start and end must be exact integer
     objects satisfying:

          0 <= start <= end <= (string-length string)

     The `SUBSTRING' procedure returns a newly allocated string formed
     from the characters of string beginning with index start
     (inclusive) and ending with index end (exclusive).

 -- Procedure: string-append string …
     Return a newly allocated string whose characters form the
     concatenation of the given strings.

 -- Procedure: string->list string
 -- Procedure: list->string list
     list must be a list of characters.

     The `STRING->LIST' procedure returns a newly allocated list of the
     characters that make up the given string.

     The `LIST->STRING' procedure returns a newly allocated string
     formed from the characters in list.

     The `STRING->LIST' and `LIST->STRING' procedures are inverses so
     far as `EQUAL?' is concerned.

 -- Procedure: string-copy string
     Returns a newly allocated copy of the given string.


File: kawa.info,  Node: Unicode,  Next: Regular expressions,  Prev: Strings,  Up: Characters and text

9.3 Unicode character classes and conversions
=============================================

Some of the procedures that operate on characters or strings ignore the
difference between upper case and lower case.  These procedures have
`-ci' (for “case insensitive”) embedded in their names.

9.3.1 Characters
----------------

 -- Procedure: char-upcase char
 -- Procedure: char-downcase char
 -- Procedure: char-titlecase char
 -- Procedure: char-foldcase char
     These procedures take a character argument and return a character
     result.

     If the argument is an upper–case or title–case character, and if
     there is a single character that is its lower–case form, then
     `CHAR-DOWNCASE' returns that character.

     If the argument is a lower–case or title–case character, and there
     is a single character that is its upper–case form, then
     `CHAR-UPCASE' returns that character.

     If the argument is a lower–case or upper–case character, and there
     is a single character that is its title–case form, then
     `CHAR-TITLECASE' returns that character.

     If the argument is not a title–case character and there is no
     single character that is its title–case form, then `CHAR-TITLECASE'
     returns the upper–case form of the argument.

     Finally, if the character has a case–folded character, then
     `CHAR-FOLDCASE' returns that character.  Otherwise the character
     returned is the same as the argument.

     For Turkic characters `#\x130' and `#\x131', `CHAR-FOLDCASE'
     behaves as the identity function; otherwise `CHAR-FOLDCASE' is the
     same as `CHAR-DOWNCASE' composed with `CHAR-UPCASE'.

          (char-upcase #\i)               ⇒  #\I
          (char-downcase #\i)             ⇒  #\i
          (char-titlecase #\i)            ⇒  #\I
          (char-foldcase #\i)             ⇒  #\i

          (char-upcase #\ß)               ⇒  #\ß
          (char-downcase #\ß)             ⇒  #\ß
          (char-titlecase #\ß)            ⇒  #\ß
          (char-foldcase #\ß)             ⇒  #\ß

          (char-upcase #\Σ)               ⇒  #\Σ
          (char-downcase #\Σ)             ⇒  #\σ
          (char-titlecase #\Σ)            ⇒  #\Σ
          (char-foldcase #\Σ)             ⇒  #\σ

          (char-upcase #\ς)               ⇒  #\Σ
          (char-downcase #\ς)             ⇒  #\ς
          (char-titlecase #\ς)            ⇒  #\Σ
          (char-foldcase #\ς)             ⇒  #\σ

          _Note:_ `CHAR-TITLECASE' does not always return a title–case
          character.

          _Note:_ These procedures are consistent with Unicode's
          locale–independent mappings from scalar values to scalar
          values for upcase, downcase, titlecase, and case–folding
          operations.  These mappings can be extracted from
          `UnicodeData.txt' and `CaseFolding.txt' from the Unicode
          Consortium, ignoring Turkic mappings in the latter.

          Note that these character–based procedures are an incomplete
          approximation to case conversion, even ignoring the user's
          locale.  In general, case mappings require the context of a
          string, both in arguments and in result.  The `STRING-UPCASE',
          `STRING-DOWNCASE', `STRING-TITLECASE', and `STRING-FOLDCASE'
          procedures perform more general case conversion.

 -- Procedure: char-ci=? char1 char2 char3 …
 -- Procedure: char-ci<? char1 char2 char3 …
 -- Procedure: char-ci>? char1 char2 char3 …
 -- Procedure: char-ci<=? char1 char2 char3 …
 -- Procedure: char-ci>=? char1 char2 char3 …
     These procedures are similar to `CHAR=?', etc., but operate on the
     case–folded versions of the characters.

          (char-ci<? #\z #\Z)             ⇒ #f
          (char-ci=? #\z #\Z)             ⇒ #f
          (char-ci=? #\ς #\σ)             ⇒ #t

 -- Procedure: char-alphabetic? char
 -- Procedure: char-numeric? char
 -- Procedure: char-whitespace? char
 -- Procedure: char-upper-case? char
 -- Procedure: char-lower-case? char
 -- Procedure: char-title-case? char
     These procedures return `#t' if their arguments are alphabetic,
     numeric, whitespace, upper–case, lower–case, or title–case
     characters, respectively; otherwise they return `#f'.

     A character is alphabetic if it has the Unicode “Alphabetic”
     property.  A character is numeric if it has the Unicode “Numeric”
     property.  A character is whitespace if has the Unicode
     “White_Space” property.  A character is upper case if it has the
     Unicode “Uppercase” property, lower case if it has the “Lowercase”
     property, and title case if it is in the Lt general category.

          (char-alphabetic? #\a)          ⇒  #t
          (char-numeric? #\1)             ⇒  #t
          (char-whitespace? #\space)      ⇒  #t
          (char-whitespace? #\x00A0)      ⇒  #t
          (char-upper-case? #\Σ)          ⇒  #t
          (char-lower-case? #\σ)          ⇒  #t
          (char-lower-case? #\x00AA)      ⇒  #t
          (char-title-case? #\I)          ⇒  #f
          (char-title-case? #\x01C5)      ⇒  #t

 -- Procedure: char-general-category char
     Return a symbol representing the Unicode general category of char,
     one of `Lu', `Ll', `Lt', `Lm', `Lo', `Mn', `Mc', `Me', `Nd', `Nl',
     `No', `Ps', `Pe', `Pi', `Pf', `Pd', `Pc', `Po', `Sc', `Sm', `Sk',
     `So', `Zs', `Zp', `Zl', `Cc', `Cf', `Cs', `Co', or `Cn'.

          (char-general-category #\a)         ⇒ Ll
          (char-general-category #\space)     ⇒ Zs
          (char-general-category #\x10FFFF)   ⇒ Cn  

9.3.2 Strings
-------------

 -- Procedure: string-upcase string
 -- Procedure: string-downcase string
 -- Procedure: string-titlecase string
 -- Procedure: string-foldcase string
     These procedures take a string argument and return a string result.
     They are defined in terms of Unicode's locale–independent case
     mappings from Unicode scalar–value sequences to scalar–value
     sequences.  In particular, the length of the result string can be
     different from the length of the input string.  When the specified
     result is equal in the sense of `STRING=?' to the argument, these
     procedures may return the argument instead of a newly allocated
     string.

     The `STRING-UPCASE' procedure converts a string to upper case;
     `STRING-DOWNCASE' converts a string to lower case.  The
     `STRING-FOLDCASE' procedure converts the string to its case–folded
     counterpart, using the full case–folding mapping, but without the
     special mappings for Turkic languages.  The `STRING-TITLECASE'
     procedure converts the first cased character of each word, and
     downcases all other cased characters.

          (string-upcase "Hi")              ⇒ "HI"
          (string-downcase "Hi")            ⇒ "hi"
          (string-foldcase "Hi")            ⇒ "hi"

          (string-upcase "Straße")          ⇒ "STRASSE"
          (string-downcase "Straße")        ⇒ "straße"
          (string-foldcase "Straße")        ⇒ "strasse"
          (string-downcase "STRASSE")       ⇒ "strasse"

          (string-downcase "Σ")             ⇒ "σ"
          ; Chi Alpha Omicron Sigma:
          (string-upcase "ΧΑΟΣ")            ⇒ "ΧΑΟΣ"
          (string-downcase "ΧΑΟΣ")          ⇒ "χαος"
          (string-downcase "ΧΑΟΣΣ")         ⇒ "χαοσς"
          (string-downcase "ΧΑΟΣ Σ")        ⇒ "χαος σ"
          (string-foldcase "ΧΑΟΣΣ")         ⇒ "χαοσσ"
          (string-upcase "χαος")            ⇒ "ΧΑΟΣ"
          (string-upcase "χαοσ")            ⇒ "ΧΑΟΣ"

          (string-titlecase "kNock KNoCK")  ⇒ "Knock Knock"
          (string-titlecase "who's there?") ⇒ "Who's There?"
          (string-titlecase "r6rs")         ⇒ "R6rs"
          (string-titlecase "R6RS")         ⇒ "R6rs"

          _Note:_ The case mappings needed for implementing these
          procedures can be extracted from `UnicodeData.txt',
          `SpecialCasing.txt', `WordBreakProperty.txt' (the “MidLetter”
          property partly defines case–ignorable characters), and
          `CaseFolding.txt' from the Unicode Consortium.

          Since these procedures are locale–independent, they may not be
          appropriate for some locales.

          _Note:_ Word breaking, as needed for the correct casing of the
          upper case greek sigma and for `STRING-TITLECASE', is
          specified in Unicode Standard Annex #29.

          _Kawa Note:_  The implementation of `STRING-TITLECASE' does
          not correctly handle the case where an initial character needs
          to be converted to multiple characters, such as “LATIN SMALL
          LIGATURE FL” which should be converted to the two letters
          `"Fl"'.

 -- Procedure: string-ci=? string1 string2 string3 …
 -- Procedure: string-ci<? string1 string2 string3 …
 -- Procedure: string-ci>? string1 string2 string3 …
 -- Procedure: string-ci<=? string1 string2 string3 …
 -- Procedure: string-ci>=? string1 string2 string3 …
     These procedures are similar to `STRING=?', etc., but operate on
     the case–folded versions of the strings.

          (string-ci<? "z" "Z")                   ⇒ #f
          (string-ci=? "z" "Z")                   ⇒ #t
          (string-ci=? "Straße" "Strasse")        ⇒ #t
          (string-ci=? "Straße" "STRASSE")        ⇒ #t
          (string-ci=? "ΧΑΟΣ" "χαοσ")             ⇒ #t

 -- Procedure: string-normalize-nfd string
 -- Procedure: string-normalize-nfkd string
 -- Procedure: string-normalize-nfc string
 -- Procedure: string-normalize-nfkc string
     These procedures take a string argument and return a string result,
     which is the input string normalized to Unicode normalization form
     D, KD, C, or KC, respectively.  When the specified result is equal
     in the sense of `STRING=?' to the argument, these procedures may
     return the argument instead of a newly allocated string.

          (string-normalize-nfd "\xE9;")          ⇒ "\x65;\x301;"
          (string-normalize-nfc "\xE9;")          ⇒ "\xE9;"
          (string-normalize-nfd "\x65;\x301;")    ⇒ "\x65;\x301;"
          (string-normalize-nfc "\x65;\x301;")    ⇒ "\xE9;"

9.3.3 Deprecated in-place case modification
-------------------------------------------

The following functions are deprecated; they really don't and cannot do
the right thing, because in some languages upper and lower case can use
different number of characters.

 -- Procedure: string-upcase! str
     _Deprecated:_ Destructively modify str, replacing the letters by
     their upper-case equivalents.

 -- Procedure: string-downcase! str
     _Deprecated:_ Destructively modify str, replacing the letters by
     their upper-lower equivalents.

 -- Procedure: string-capitalize! str
     _Deprecated:_ Destructively modify str, such that the letters that
     start a new word are replaced by their title-case equivalents,
     while non-initial letters are replaced by their lower-case
     equivalents.


File: kawa.info,  Node: Regular expressions,  Prev: Unicode,  Up: Characters and text

9.4 Regular expressions
=======================

Kawa provides "regular expressions", which is a convenient mechanism for
matching a string against a "pattern" and maybe replacing matching
parts.

   A regexp is a string that describes a pattern. A regexp matcher tries
to match this pattern against (a portion of) another string, which we
will call the text string. The text string is treated as raw text and
not as a pattern.

   Most of the characters in a regexp pattern are meant to match
occurrences of themselves in the text string. Thus, the pattern “`abc'”
matches a string that contains the characters “`a'”, “`b'”, “`c'” in
succession.

   In the regexp pattern, some characters act as "metacharacters", and
some character sequences act as "metasequences". That is, they specify
something other than their literal selves. For example, in the pattern
“`a.c'”, the characters “`a'” and “`c'” do stand for themselves but the
metacharacter “`.'” can match any character (other than newline).
Therefore, the pattern “`a.c'” matches an “`a'”, followed by any
character, followed by a “`c'”.

   If we needed to match the character “`.'” itself, we "escape" it, ie,
precede it with a backslash “`\'”. The character sequence “`\.'” is thus
a metasequence, since it doesn’t match itself but rather just “`.'”.
So, to match “`a'” followed by a literal “`.'” followed by “`c'” we use
the regexp pattern “`a\.c'”.  To write this as a Scheme string literal,
you need to quote the backslash, so you need to write `"a\\.c"'.  Kawa
also allows the literal syntax `#/a\.c/', which avoids the need to
double the backslashes.

   You can choose between two similar styles of regular expressions.
The two differ slightly in terms of which characters act as
metacharacters, and what those metacharacters mean:
   • Functions starting with `regex-' are implemented using the
     `java.util.regex' package.  This is likely to be more efficient,
     has better Unicode support and some other minor extra features, and
     literal syntax `#/a\.c/' mentioned above.

   • Functions starting with `pregexp-' are implemented in pure Scheme
     using Dorai Sitaram's “Portable Regular Expressions for Scheme”
     library.  These will be portable to more Scheme implementations,
     including BRL, and is available on older Java versions.

9.4.1 Java regular expressions
------------------------------

The syntax for regular expressions is documented here
(http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html).

 -- Type: regex
     A compiled regular expression, implemented as
     `java.util.regex.Pattern'.

 -- Constructor: regex arg
     Given a regular expression pattern (as a string), compiles it to a
     `regex' object.

          (regex "a\\.c")

     This compiles into a pattern that matches an “`a'”, followed by any
     character, followed by a “`c'”.

   The Scheme reader recognizes “`#/'” as the start of a regular
expression "pattern literal", which ends with the next un-escaped “`/'”.
This has the big advantage that you don't need to double the
backslashes:
     #/a\.c/
   This is equivalent to `(regex "a\\.c")', except it is compiled at
read-time.  If you need a literal “`/'” in a pattern, just escape it
with a backslash: “`#/a\/c/'” matches a “`a'”, followed by a “`/'”,
followed by a “`c'”.

   You can add single-letter _modifiers_ following the pattern literal.
The following modifiers are allowed:
`i'
     The modifier “`i'” cause the matching to ignore case.  For example
     the following pattern matches “`a'” or “`A'”.

          #/a/i

`m'
     Enables “metaline” mode.  Normally metacharacters “`^'” and “`$''
     match at the start end end of the entire input string.  In metaline
     mode “`^'” and “`$'” also match just before or after a line
     terminator.

     Multiline mode can also be enabled by the metasequence “`(?m)'”.

`s'
     Enable “singleline” (aka “dot-all”) mode.  In this mode the
     matacharacter “`.' matches any character, including a line breaks.
     This mode be enabled by the metasequence “`(?s)'”.

   The following functions accept a regex either as a pattern string or
a compiled `regex' pattern.  I.e. the following are all equivalent:
     (regex-match "b\\.c" "ab.cd")
     (regex-match #/b\.c/ "ab.cd")
     (regex-match (regex "b\\.c") "ab.cd")
     (regex-match (java.util.regex.Pattern:compile "b\\.c") "ab.cd")
   These all evaluate to the list `("b.c")'.

   The following functions must be imported by doing one of:
     (require 'regex) ;; or
     (import (kawa regex))

 -- Procedure: regex-match-positions regex string [start [end]]
     The procedure `regex‑match‑position' takes pattern and a text
     string, and returns a match if the regex matches (some part of) the
     text string.

     Returns `#f' if the regexp did not match the string; and a list of
     index pairs if it did match.

          (regex-match-positions "brain" "bird") ⇒ #f
          (regex-match-positions "needle" "hay needle stack")
            ⇒ ((4 . 10))

     In the second example, the integers 4 and 10 identify the substring
     that was matched. 4 is the starting (inclusive) index and 10 the
     ending (exclusive) index of the matching substring.

          (substring "hay needle stack" 4 10) ⇒ "needle"

     In this case the return list contains only one index pair, and that
     pair represents the entire substring matched by the regexp. When we
     discuss subpatterns later, we will see how a single match operation
     can yield a list of submatches.

     `regex‑match‑positions' takes optional third and fourth arguments
     that specify the indices of the text string within which the
     matching should take place.

          (regex-match-positions "needle"
            "his hay needle stack -- my hay needle stack -- her hay needle stack"
            24 43)
            ⇒ ((31 . 37))

     Note that the returned indices are still reckoned relative to the
     full text string.

 -- Procedure: regex-match regex string [start [end]]
     The procedure `regex‑match' is called like `regex‑match‑positions'
     but instead of returning index pairs it returns the matching
     substrings:

          (regex-match "brain" "bird") ⇒ #f
          (regex-match "needle" "hay needle stack")
            ⇒ ("needle")

     `regex‑match' also takes optional third and fourth arguments, with
     the same meaning as does `regex‑match‑positions'.

 -- Procedure: regex-split regex string
     Takes two arguments, a regex pattern and a text string, and returns
     a list of substrings of the text string, where the pattern
     identifies the delimiter separating the substrings.

          (regex-split ":" "/bin:/usr/bin:/usr/bin/X11:/usr/local/bin")
            ⇒ ("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")

          (regex-split " " "pea soup")
            ⇒ ("pea" "soup")

     If the first argument can match an empty string, then the list of
     all the single-character substrings is returned, plus we get a
     empty strings at each end.

          (regex-split "" "smithereens")
          ⇒ => ("" "s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s" "")

     (Note: This behavior is different from `pregexp-split'.)

     To identify one-or-more spaces as the delimiter, take care to use
     the regexp “` +'”, not “` *'”.

          (regex-split " +" "split pea     soup")
            ⇒ ("split" "pea" "soup")
          (regex-split " *" "split pea     soup")
            ⇒ ("" "s" "p" "l" "i" "t" "" "p" "e" "a" "" "s" "o" "u" "p" "")

 -- Procedure: regex‑replace regex string replacement
     Replaces the matched portion of the text string by another a
     replacdement string.

          (regex-replace "te" "liberte" "ty")
            ⇒ "liberty"

     Submatches can be used in the replacement string argument.  The
     replacement string can use “`$n'” as a "backreference" to refer
     back to the nth submatch, ie, the substring that matched the nth
     subpattern.   “`$0'” refers to the entire match.

          (regex-replace #/_(.+?)_/
                         "the _nina_, the _pinta_, and the _santa maria_"
          		"*$1*"))
            ⇒ "the *nina*, the _pinta_, and the _santa maria_"

 -- Procedure: regex‑replace* regex string replacement
     Replaces all matches in the text string by the replacement string:

          (regex-replace* "te" "liberte egalite fraternite" "ty")
            ⇒ "liberty egality fratyrnity"
          (regex-replace* #/_(.+?)_/
                          "the _nina_, the _pinta_, and the _santa maria_"
                          "*$1*")
            ⇒ "the *nina*, the *pinta*, and the *santa maria*"

 -- Procedure: regex-quote pattern
     Takes an arbitrary string and returns a pattern string that
     precisely matches it. In particular, characters in the input string
     that could serve as regex metacharacters are escaped as needed.

          (regex-quote "cons")
            ⇒ "\Qcons\E"

     `regex‑quote' is useful when building a composite regex from a mix
     of regex strings and verbatim strings.

9.4.2 Portable Scheme regular expressions
-----------------------------------------

This provides the procedures `pregexp', `pregexp‑match‑positions',
`pregexp‑match', `pregexp‑split', `pregexp‑replace', `pregexp‑replace*',
and `pregexp‑quote'.

   Before using them, you must require them:
     (require 'pregexp)

   These procedures have the same interface as the corresponding
`regex-' versions, but take slightly different pattern syntax.  The
replace commands use “`\'” instead of “`$'” to indicate substitutions.
Also, `pregexp‑split' behaves differently from `regex‑split' if the
pattern can match an empty string.

   See here for details (http://evalwhen.com/pregexp/index.html).


File: kawa.info,  Node: Data structures,  Next: Exceptions,  Prev: Characters and text,  Up: Top

10 Data structures
******************

* Menu:

* Lists::
* Arrays::  Multi-dimensional Arrays
* Uniform vectors::
* Hash tables::


File: kawa.info,  Node: Lists,  Next: Arrays,  Up: Data structures

10.1 Lists
==========

The SRFI-1 List Library (http://srfi.schemers.org/srfi-1/srfi-1.html) is
available, though not enabled by default.  To use its functions you must
`(require 'list-lib)' or `(require 'srfi-1)'.
     (require 'list-lib)
     (iota 5 0 -0.5) ⇒ (0.0 -0.5 -1.0 -1.5 -2.0)

 -- Procedure: reverse! list
     The result is a list consisting of the elements of list in reverse
     order.  No new pairs are allocated, instead the pairs of list are
     re-used, with `cdr' cells of list reversed in place.  Note that if
     list was pair, it becomes the last pair of the reversed result.


File: kawa.info,  Node: Arrays,  Next: Uniform vectors,  Prev: Lists,  Up: Data structures

10.2 Multi-dimensional Arrays
=============================

Arrays are heterogeneous data structures whose elements are indexed by
integer sequences of fixed length.  The length of a valid index sequence
is the rank or the number of dimensions of an array. The shape of an
array consists of bounds for each index.

   The lower bound b and the upper bound e of a dimension are exact
integers with `(<= b e)'. A valid index along the dimension is an exact
integer k that satisfies both `(<= b k)' and `(< k e)'.  The length of
the array along the dimension is the difference `(- e b)'.  The size of
an array is the product of the lengths of its dimensions.

   A shape is specified as an even number of exact integers. These are
alternately the lower and upper bounds for the dimensions of an array.

 -- Procedure: array? obj
     Returns `#t' if obj is an array, otherwise returns `#f'.

 -- Procedure: shape bound ...
     Returns a shape. The sequence bound ... must consist of an even
     number of exact integers that are pairwise not decreasing. Each
     pair gives the lower and upper bound of a dimension.  If the shape
     is used to specify the dimensions of an array and bound ... is the
     sequence b0 e0 ... bk ek ... of n pairs of bounds, then a valid
     index to the array is any sequence j0 ... jk ... of n exact
     integers where each jk satisfies `(<= bk jk)' and `(< jk ek)'.

     The shape of a d-dimensional array is a d * 2 array where the
     element at k 0 contains the lower bound for an index along
     dimension k and the element at k 1 contains the corresponding upper
     bound, where k satisfies `(<=  0 k)' and `(< k d)'.

 -- Procedure: make-array shape
 -- Procedure: make-array shape obj
     Returns a newly allocated array whose shape is given by shape.  If
     obj is provided, then each element is initialized to it.  Otherwise
     the initial contents of each element is unspecified.  The array
     does not retain a reference to shape.

 -- Procedure: array shape obj ...
     Returns a new array whose shape is given by shape and the initial
     contents of the elements are obj ... in row major order. The array
     does not retain a reference to shape.

 -- Procedure: array-rank array
     Returns the number of dimensions of array.

          (array-rank
            (make-array (shape 1 2 3 4)))

     Returns 2.

 -- Procedure: array-start array k
     Returns the lower bound for the index along dimension k.

 -- Procedure: array-end array k
     Returns the upper bound for the index along dimension k.

 -- Procedure: array-ref array k ...
 -- Procedure: array-ref array index
     Returns the contents of the element of array at index k ....  The
     sequence k ... must be a valid index to array.  In the second form,
     index must be either a vector or a 0-based 1-dimensional array
     containing k ....

          (array-ref (array (shape 0 2 0 3)
                        'uno 'dos 'tres
                        'cuatro 'cinco 'seis)
             1 0)

     Returns `cuatro'.

          (let ((a (array (shape 4 7 1 2) 3 1 4)))
             (list (array-ref a 4 1)
                   (array-ref a (vector 5 1))
                   (array-ref a (array (shape 0 2)
                                   6 1))))

     Returns `(3 1 4)'.

 -- Procedure: array-set! array k ... obj
 -- Procedure: array-set! array index obj
     Stores obj in the element of array at index k ....  Returns the
     void value.  The sequence k ... must be a valid index to array.  In
     the second form, index must be either a vector or a 0-based
     1-dimensional array containing k ....

          (let ((a (make-array
                      (shape 4 5 4 5 4 5))))
             (array-set! a 4 4 4 "huuhkaja")
             (array-ref a 4 4 4))

     Returns `"huuhkaja"'.

 -- Procedure: share-array array shape proc
     Returns a new array of shape shape that shares elements of array
     through proc. The procedure proc must implement an affine function
     that returns indices of array when given indices of the array
     returned by `share-array'.  The array does not retain a reference
     to shape.

          (define i_4
             (let* ((i (make-array
                          (shape 0 4 0 4)
                          0))
                    (d (share-array i
                          (shape 0 4)
                          (lambda (k)
                             (values k k)))))
                (do ((k 0 (+ k 1)))
                    ((= k 4))
                   (array-set! d k 1))
                i))

     Note: the affinity requirement for proc means that each value must
     be a sum of multiples of the arguments passed to proc, plus a
     constant.

     Implementation note: arrays have to maintain an internal index
     mapping from indices k1 ... kd to a single index into a backing
     vector; the composition of this mapping and proc can be recognised
     as `(+ n0 (* n1 k1) ... (* nd kd))' by setting each index in turn
     to 1 and others to 0, and all to 0 for the constant term; the
     composition can then be compiled away, together with any complexity
     that the user introduced in their procedure.

   Multi-dimensional arrays are specified by SRFI-25
(http://srfi.schemers.org/srfi-25/srfi-25.html).  In Kawa, a
one-dimensional array whose lower bound is 0 is also a sequence.
Furthermore, if such an array is simple (not created `share-array') it
will be implemented using a `<vector>'.  Uniform vectors and strings are
also arrays in Kawa.  For example:
     (share-array
      (f64vector 1.0 2.0 3.0 4.0 5.0 6.0)
      (shape 0 2 0 3)
      (lambda (i j) (+ (* 2 i) j)))
   evaluates to a two-dimensionsal array of `<double>':
     #2a((1.0 2.0 3.0) (3.0 4.0 5.0))


File: kawa.info,  Node: Uniform vectors,  Next: Hash tables,  Prev: Arrays,  Up: Data structures

10.3 Uniform vectors
====================

Uniform vectors are vectors whose elements are of the same numeric type.
The are defined by SRFI-4 (http://srfi.schemers.org/srfi-4/srfi-4.html).
However, the type names (such as `<s8vector>') are a Kawa extension.

 -- Variable: <s8vector>
     The type of uniform vectors where each element can contain a signed
     8-bit integer.  Represented using an array of `<byte>'.

 -- Variable: <u8vector>
     The type of uniform vectors where each element can contain an
     unsigned 8-bit integer.  Represented using an array of `<byte>',
     but each element is treated as if unsigned.

 -- Variable: <s16vector>
     The type of uniform vectors where each element can contain a signed
     16-bit integer.  Represented using an array of `<short>'.

 -- Variable: <u16vector>
     The type of uniform vectors where each element can contain an
     unsigned 16-bit integer.  Represented using an array of `<short>',
     but each element is treated as if unsigned.

 -- Variable: <s32vector>
     The type of uniform vectors where each element can contain a signed
     32-bit integer.  Represented using an array of `<int>'.

 -- Variable: <u32vector>
     The type of uniform vectors where each element can contain an
     unsigned 32-bit integer.  Represented using an array of `<int>',
     but each element is treated as if unsigned.

 -- Variable: <s64vector>
     The type of uniform vectors where each element can contain a signed
     64-bit integer.  Represented using an array of `<long>'.

 -- Variable: <u64vector>
     The type of uniform vectors where each element can contain an
     unsigned 64-bit integer.  Represented using an array of `<long>',
     but each element is treated as if unsigned.

 -- Variable: <f32vector>
     The type of uniform vectors where each element can contain a 32-bit
     floating-point real.  Represented using an array of `<float>'.

 -- Variable: <f64vector>
     The type of uniform vectors where each element can contain a 64-bit
     floating-point real.  Represented using an array of `<double>'.

 -- Procedure: s8vector? value
 -- Procedure: u8vector? value
 -- Procedure: s16vector? value
 -- Procedure: u16vector? value
 -- Procedure: s32vector? value
 -- Procedure: u32vector? value
 -- Procedure: s64vector? value
 -- Procedure: u64vector? value
 -- Procedure: f32vector? value
 -- Procedure: f64vector? value
     Return true iff value is a uniform vector of the specified type.

 -- Procedure: make-s8vector n [value]
 -- Procedure: make-u8vector n [value]
 -- Procedure: make-s16vector n [value]
 -- Procedure: make-u16vector n [value]
 -- Procedure: make-s32vector n [value]
 -- Procedure: make-u32vector n [value]
 -- Procedure: make-s64vector n [value]
 -- Procedure: make-u64vector n [value]
 -- Procedure: make-f32vector n [value]
 -- Procedure: make-f64vector n [value]
     Create a new uniform vector of the specified type, having room for
     n elements.  Initialize each element to value if it is specified;
     zero otherwise.

 -- Procedure: s8vector value ...
 -- Procedure: u8vector value ...
 -- Procedure: s16vector value ..
 -- Procedure: u16vector value ...
 -- Procedure: s32vector value ...
 -- Procedure: u32vector value ...
 -- Procedure: s64vector value ...
 -- Procedure: u64vector value ...
 -- Procedure: f32vector value ...
 -- Procedure: f64vector value ...
     Create a new uniform vector of the specified type, whose length is
     the number of values specified, and initialize it using those
     values.

 -- Procedure: s8vector-length v
 -- Procedure: u8vector-length v
 -- Procedure: s16vector-length v
 -- Procedure: u16vector-length v
 -- Procedure: s32vector-length v
 -- Procedure: u32vector-length v
 -- Procedure: s64vector-length v
 -- Procedure: u64vector-length v
 -- Procedure: f32vector-length v
 -- Procedure: f64vector-length v
     Return the length (in number of elements) of the uniform vector v.

 -- Procedure: s8vector-ref v i
 -- Procedure: u8vector-ref v i
 -- Procedure: s16vector-ref v i
 -- Procedure: u16vector-ref v i
 -- Procedure: s32vector-ref v i
 -- Procedure: u32vector-ref v i
 -- Procedure: s64vector-ref v i
 -- Procedure: u64vector-ref v i
 -- Procedure: f32vector-ref v i
 -- Procedure: f64vector-ref v i
     Return the element at index i of the uniform vector v.

 -- Procedure: s8vector-set! v i x
 -- Procedure: u8vector-set! v i x
 -- Procedure: s16vector-set! v i x
 -- Procedure: u16vector-set! v i x
 -- Procedure: s32vector-set! v i x
 -- Procedure: u32vector-set! v i x
 -- Procedure: s64vector-set! v i x
 -- Procedure: u64vector-set! v i x
 -- Procedure: f32vector-set! v i x
 -- Procedure: f64vector-set! v i x
     Set the element at index i of uniform vector v to the value x,
     which must be a number coercible to the appropriate type.

 -- Procedure: s8vector->list v
 -- Procedure: u8vector->list v
 -- Procedure: s16vector->list v
 -- Procedure: u16vector->list v
 -- Procedure: s32vector->list v
 -- Procedure: u32vector->list v
 -- Procedure: s64vector->list v
 -- Procedure: u64vector->list v
 -- Procedure: f32vector->list v
 -- Procedure: f64vector->list v
     Convert the uniform vetor v to a list containing the elments of v.

 -- Procedure: list->s8vector l
 -- Procedure: list->u8vector l
 -- Procedure: list->s16vector l
 -- Procedure: list->u16vector l
 -- Procedure: list->s32vector l
 -- Procedure: list->u32vector l
 -- Procedure: list->s64vector l
 -- Procedure: list->u64vector l
 -- Procedure: list->f32vector l
 -- Procedure: list->f64vector l
     Create a uniform vector of the appropriate type, initializing it
     with the elements of the list l.  The elements of l must be numbers
     coercible the new vector's element type.

10.3.1 Relationship with Java arrays
------------------------------------

Each uniform array type is implemented as an "underlying Java array",
and a length field.  The underlying type is `byte[]' for `<u8vector>' or
`<s8vector>'; `short[]' for `<u16vector>' or `<u16vector>'; `int[]' for
`<u32vector>' or `<s32vector>'; `long[]' for `<u64vector>' or
`<s64vector>'; `<float[]' for `<f32vector>'; and `<double[]' for
`<f32vector>'.  The length field allows a uniform array to only use the
initial part of the underlying array.  (This can be used to support
Common Lisp's fill pointer feature.)  This also allows resizing a
uniform vector.  There is no Scheme function for this, but you can use
the `setSize' method:
     (invoke some-vector 'setSize 200)

   If you have a Java array, you can create a uniform vector sharing
with the Java array:
     (define arr :: <byte[]> ((primitive-array-new <byte>) 10))
     (define vec :: <u8vector> (make <u8vector> arr))
   At this point `vec' uses `arr' for its underlying storage, so changes
to one affect the other.  It `vec' is re-sized so it needs a larger
underlying array, then it will no longer use `arr'.


File: kawa.info,  Node: Hash tables,  Prev: Uniform vectors,  Up: Data structures

10.4 Hash tables
================

A "hashtable" is a data structure that associates keys with values.  The
hashtable has no intrinsic order for the (key, value) associations it
contains, and supports in-place modification as the primary means of
setting the contents of a hash table.  Any object can be used as a key,
provided a "hash function" and a suitable "equivalence function" is
available.  A hash function is a procedure that maps keys to exact
integer objects.

   The hashtable provides key lookup and destructive update in amortised
constant time, provided that a good hash function is used.  A hash
function h is acceptable for an equivalence predicate e iff `(e obj1
obj2)' implies `(= (h obj1) (h obj2))'.  A hash function h is good for a
equivalence predicate e if it distributes the resulting hash values for
non-equal objects (by e) as uniformly as possible over the range of hash
values, especially in the case when some (non-equal) objects resemble
each other by e.g. having common subsequences. This definition is vague
but should be enough to assert that e.g. a constant function is not a
good hash function.

   Kawa provides two complete sets of functions for hashtables:
   • The functions specified by R6RS have names starting with
     `hashtable-'

   • The functions specified by the older SRFI-69
     (http://srfi.schemers.org/srfi-69/srfi-69.html) specifiation have
     names starting with `hash-table-'

   Both interfaces use the same underlying datatype, so it is possible
to mix and match from both sets.  That datatype implements
`java.util.Map'.  Freshly-written code should probably use the R6RS
functions.

10.4.1 R6RS hash tables
-----------------------

To use these hash table functions in your Kawa program you must first:

     (import (rnrs hashtables))

   This section uses the hashtable parameter name for arguments that
must be hashtables, and the key parameter name for arguments that must
be hashtable keys.

 -- Procedure: make-eq-hashtable
 -- Procedure: make-eq-hashtable k
     Return a newly allocated mutable hashtable that accepts arbitrary
     objects as keys, and compares those keys with `EQ?'.  If an
     argument is given, the initial capacity of the hashtable is set to
     approximately k elements.

 -- Procedure: make-eqv-hashtable
 -- Procedure: make-eqv-hashtable k
     Return a newly allocated mutable hashtable that accepts arbitrary
     objects as keys, and compares those keys with `EQV?'.  If an
     argument is given, the initial capacity of the hashtable is set to
     approximately k elements.

 -- Procedure: make-hashtable hash-function equiv
 -- Procedure: make-hashtable hash-function equiv k
     hash-function and equiv must be procedures.  hash-function should
     accept a key as an argument and should return a non–negative exact
     integer object.  equiv should accept two keys as arguments and
     return a single value.  Neither procedure should mutate the
     hashtable returned by `MAKE-HASHTABLE'.

     The `MAKE-HASHTABLE' procedure returns a newly allocated mutable
     hashtable using hash-function as the hash function and equiv as the
     equivalence function used to compare keys.  If a third argument is
     given, the initial capacity of the hashtable is set to
     approximately k elements.

     Both hash-function and equiv should behave like pure functions on
     the domain of keys.  For example, the `STRING-HASH' and `STRING=?'
     procedures are permissible only if all keys are strings and the
     contents of those strings are never changed so long as any of them
     continues to serve as a key in the hashtable.  Furthermore, any
     pair of keys for which equiv returns true should be hashed to the
     same exact integer objects by hash-function.

          _Note:_ Hashtables are allowed to cache the results of calling
          the hash function and equivalence function, so programs cannot
          rely on the hash function being called for every lookup or
          update.  Furthermore any hashtable operation may call the hash
          function more than once.

10.4.1.1 Procedures
...................

 -- Procedure: hashtable? obj
     Return `#t' if obj is a hashtable, `#f' otherwise.

 -- Procedure: hashtable-size hashtable
     Return the number of keys contained in hashtable as an exact
     integer object.

 -- Procedure: hashtable-ref hashtable key default
     Return the value in hashtable associated with key.  If hashtable
     does not contain an association for key, default is returned.

 -- Procedure: hashtable-set! hashtable key obj
     Change hashtable to associate key with obj, adding a new
     association or replacing any existing association for key, and
     returns unspecified values.

 -- Procedure: hashtable-delete! hashtable key
     Remove any association for key within hashtable and returns
     unspecified values.

 -- Procedure: hashtable-contains? hashtable key
     Return `#t' if hashtable contains an association for key, `#f'
     otherwise.

 -- Procedure: hashtable-update! hashtable key proc default
     proc should accept one argument, should return a single value, and
     should not mutate hashtable.

     The `HASHTABLE-UPDATE!' procedure applies proc to the value in
     hashtable associated with key, or to default if hashtable does not
     contain an association for key.  The hashtable is then changed to
     associate key with the value returned by proc.

     The behavior of `HASHTABLE-UPDATE!' is equivalent to the following
     code, but is may be (and is in Kawa) implemented more efficiently
     in cases where the implementation can avoid multiple lookups of the
     same key:

          (hashtable-set!
            hashtable key
            (proc (hashtable-ref
                   hashtable key default)))

 -- Procedure: hashtable-copy hashtable
 -- Procedure: hashtable-copy hashtable mutable
     Return a copy of hashtable.  If the mutable argument is provided
     and is true, the returned hashtable is mutable; otherwise it is
     immutable.

 -- Procedure: hashtable-clear! hashtable
 -- Procedure: hashtable-clear! hashtable k
     Remove all associations from hashtable and returns unspecified
     values.

     If a second argument is given, the current capacity of the
     hashtable is reset to approximately k elements.

 -- Procedure: hashtable-keys hashtable
     Return a vector of all keys in hashtable.  The order of the vector
     is unspecified.

 -- Procedure: hashtable-entries hashtable
     Return two values, a vector of the keys in hashtable, and a vector
     of the corresponding values.

     Example:

          (let ((h (make-eqv-hashtable)))
            (hashtable-set! h 1 'one)
            (hashtable-set! h 2 'two)
            (hashtable-set! h 3 'three)
            (hashtable-entries h))
          => #(1 2 3) #(one two three) ; two return values

     the order of the entries in the result vectors is not known.

10.4.1.2 Inspection
...................

 -- Procedure: hashtable-equivalence-function hashtable
     Return the equivalence function used by hashtable to compare keys.
     For hashtables created with `MAKE-EQ-HASHTABLE' and
     `MAKE-EQV-HASHTABLE', returns `EQ?' and `EQV?' respectively.

 -- Procedure: hashtable-hash-function hashtable
     Return the hash function used by hashtable.  For hashtables created
     by `MAKE-EQ-HASHTABLE' or `MAKE-EQV-HASHTABLE', `#f' is returned.

 -- Procedure: hashtable-mutable? hashtable
     Return `#t' if hashtable is mutable, otherwise `#f'.

10.4.1.3 Hash functions
.......................

The `EQUAL-HASH', `STRING-HASH', and `STRING-CI-HASH' procedures of this
section are acceptable as the hash functions of a hashtable only if the
keys on which they are called are not mutated while they remain in use
as keys in the hashtable.

 -- Procedure: equal-hash obj
     Return an integer hash value for obj, based on its structure and
     current contents.  This hash function is suitable for use with
     `EQUAL?' as an equivalence function.

          _Note:_ Like `EQUAL?', the `EQUAL-HASH' procedure must always
          terminate, even if its arguments contain cycles.

 -- Procedure: string-hash string
     Return an integer hash value for string, based on its current
     contents.  This hash function is suitable for use with `STRING=?'
     as an equivalence function.

 -- Procedure: string-ci-hash string
     Return an integer hash value for string based on its current
     contents, ignoring case.  This hash function is suitable for use
     with `STRING-CI=?' as an equivalence function.

 -- Procedure: symbol-hash symbol
     Return an integer hash value for symbol.

10.4.2 SRFI-69 hash tables
--------------------------

To use these hash table functions in your Kawa program you must first:
     (require 'srfi-69)
   or
     (require 'hash-table)
   or
     (import (srfi :69 basic-hash-tables))

10.4.2.1 Type constructors and predicate
........................................

 -- Procedure: make-hash-table [ equal? [ hash [ size-hint]]] →
          hash-table
     Create a new hash table with no associations.  The equal? parameter
     is a predicate that should accept two keys and return a boolean
     telling whether they denote the same key value; it defaults to the
     `equal?' function.

     The hash parameter is a hash function, and defaults to an
     appropriate hash function for the given equal? predicate (see the
     Hashing section).  However, an acceptable default is not guaranteed
     to be given for any equivalence predicate coarser than `equal?',
     except for `string-ci=?'.  (The function `hash' is acceptable for
     `equal?', so if you use coarser equivalence than `equal?' other
     than `string-ci=?', you must always provide the function hash
     yourself.)  (An equivalence predicate c1 is coarser than a
     equivalence predicate c2 iff there exist values x and y such that
     `(and (c1 x y) (not (c2 x y)))'.)

     The size-hint parameter can be used to suggested an approriate
     initial size.  This option is not part of the SRFI-69 specification
     (though it is handled by the reference implementation), so
     specifying that option might be unportable.

 -- Procedure: hash-table? obj → boolean
     A predicate to test whether a given object obj is a hash table.

 -- Procedure: alist->hash-table alist [ equal? [ hash [ size-hint]]] →
          hash-table
     Takes an association list alist and creates a hash table hash-table
     which maps the `car' of every element in alist to the `cdr' of
     corresponding elements in alist. The equal?, hash, and size-hint
     parameters are interpreted as in `make-hash-table'. If some key
     occurs multiple times in alist, the value in the first association
     will take precedence over later ones. (Note: the choice of using
     `cdr' (instead of `cadr') for values tries to strike balance
     between the two approaches: using cadr would render this procedure
     unusable for `cdr' alists, but not vice versa.)

10.4.2.2 Reflective queries
...........................

 -- Procedure: hash-table-equivalence-function hash-table
     Returns the equivalence predicate used for keys of hash-table.

 -- Procedure: hash-table-hash-function hash-table
     Returns the hash function used for keys of hash-table.

10.4.2.3 Dealing with single elements
.....................................

 -- Procedure: hash-table-ref hash-table key [ thunk ] → value
     This procedure returns the value associated to key in hash-table.
     If no value is associated to key and thunk is given, it is called
     with no arguments and its value is returned; if thunk is not given,
     an error is signalled. Given a good hash function, this operation
     should have an (amortised) complexity of O(1) with respect to the
     number of associations in hash-table.

 -- Procedure: hash-table-ref/default hash-table key default → value
     Evaluates to the same value as `(hash-table-ref hash-table key
     (lambda () default))'. Given a good hash function, this operation
     should have an (amortised) complexity of O(1) with respect to the
     number of associations in hash-table.

 -- Procedure: hash-table-set! hash-table key value → void
     This procedure sets the value associated to key in hash-table. The
     previous association (if any) is removed. Given a good hash
     function, this operation should have an (amortised) complexity of
     O(1) with respect to the number of associations in hash-table.

 -- Procedure: hash-table-delete! hash-table key → void
     This procedure removes any association to key in hash-table. It is
     not an error if no association for the key exists; in this case,
     nothing is done. Given a good hash function, this operation should
     have an (amortised) complexity of O(1) with respect to the number
     of associations in hash-table.

 -- Procedure: hash-table-exists? hash-table key → boolean
     This predicate tells whether there is any association to key in
     hash-table. Given a good hash function, this operation should have
     an (amortised) complexity of O(1) with respect to the number of
     associations in hash-table.

 -- Procedure: hash-table-update! hash-table key function [ thunk ] →
          void
     Semantically equivalent to, but may be implemented more efficiently
     than, the following code:

          (hash-table-set! hash-table key
                           (function (hash-table-ref hash-table key thunk)))

 -- Procedure: hash-table-update!/default hash-table key function
          default → void
     Behaves as if it evaluates to `(hash-table-update! hash-table key
     function (lambda () default))'.

10.4.2.4 Dealing with the whole contents
........................................

 -- Procedure: hash-table-size hash-table → integer
     Returns the number of associations in hash-table. This operation
     takes constant time.

 -- Procedure: hash-table-keys hash-table → list
     Returns a list of keys in hash-table.  The order of the keys is
     unspecified.

 -- Procedure: hash-table-values hash-table → list
     Returns a list of values in hash-table. The order of the values is
     unspecified, and is not guaranteed to match the order of keys in
     the result of `hash-table-keys'.

 -- Procedure: hash-table-walk hash-table proc → void
     proc should be a function taking two arguments, a key and a value.
     This procedure calls proc for each association in hash-table,
     giving the key of the association as key and the value of the
     association as value. The results of proc are discarded. The order
     in which proc is called for the different associations is
     unspecified.

 -- Procedure: hash-table-fold hash-table f init-value → final-value
     This procedure calls f for every association in hash-table with
     three arguments: the key of the association key, the value of the
     association value, and an accumulated value, val. The val is
     init-value for the first invocation of f, and for subsequent
     invocations of f, the return value of the previous invocation of f.
     The value final-value returned by `hash-table-fold' is the return
     value of the last invocation of f. The order in which f is called
     for different associations is unspecified.

 -- Procedure: hash-table->alist hash-table → alist
     Returns an association list such that the `car' of each element in
     alist is a key in hash-table and the corresponding `cdr' of each
     element in alist is the value associated to the key in hash-table.
     The order of the elements is unspecified.

     The following should always produce a hash table with the same
     mappings as a hash table h:

          (alist->hash-table (hash-table->alist h)
                                  (hash-table-equivalence-function h)
                                  (hash-table-hash-function h))

 -- Procedure: hash-table-copy hash-table → hash-table
     Returns a new hash table with the same equivalence predicate, hash
     function and mappings as in hash-table.

 -- Procedure: hash-table-merge! hash-table1 hash-table2 → hash-table
     Adds all mappings in hash-table2 into hash-table1 and returns the
     resulting hash table. This function may modify hash-table1
     destructively.

10.4.2.5 Hash functions
.......................

The Kawa implementation always calls these hash functions with a single
parameter, and expects the result to be within the entire (32-bit
signed) `<int>' range, for compatibility with standard `hashCode'
methods.

 -- Procedure: hash object [ bound ] → integer
     Produces a hash value for object in the range from 0 (inclusive) tp
     to bound (exclusive).

     If bound is not given, the Kawa implementation returns a value
     within the range `(- (expt 2 32))' (inclusive) to
     `(- (expt 2 32) 1)' (inclusive).  It does this by calling the
     standard `hashCode' method, and returning the result as is.  (If
     the object is the Java `null' value, 0 is returned.)  This hash
     function is acceptable for `equal?'.

 -- Procedure: string-hash string [ bound ] → integer
     The same as `hash', except that the argument string must be a
     string.  (The Kawa implementation returns the same as the `hash'
     function.)

 -- Procedure: string-ci-hash string [ bound ] → integer
     The same as `string-hash', except that the case of characters in
     string does not affect the hash value produced.  (The Kawa
     implementation returns the same the `hash' function applied to the
     lower-cased string.)

 -- Procedure: hash-by-identity object [ bound ] → integer
     The same as `hash', except that this function is only guaranteed to
     be acceptable for `eq?'.  Kawa uses the `identityHashCode' method
     of `java.lang.System'.


File: kawa.info,  Node: Exceptions,  Next: Eval and Environments,  Prev: Data structures,  Up: Top

11 Exception handling
*********************

 -- Procedure: catch key thunk handler
     Invoke thunk in the dynamic context of handler for exceptions
     matching key.  If thunk throws to the symbol key, then handler is
     invoked this way:

          (handler key args ...)

     key may be a symbol.  The thunk takes no arguments.  If thunk
     returns normally, that is the return value of `catch'.

     Handler is invoked outside the scope of its own `catch'.  If
     handler again throws to the same key, a new handler from further up
     the call chain is invoked.

     If the key is `#t', then a throw to _any_ symbol will match this
     call to `catch'.

 -- Procedure: throw key &rest args ...
     Invoke the catch form matching key, passing args to the handler.

     If the key is a symbol it will match catches of the same symbol or
     of #t.

     If there is no handler at all, an error is signaled.

 -- procedure: error message args ...
     Raise an error with key `misc-error' and a message constructed by
     displaying msg and writing args.  This normally prints a stack
     trace, and brings you back to the top level, or exits kawa if you
     are not running interactively.  This procedure is part of SRFI-23,
     and other Scheme implementations.

 -- Procedure: primitive-throw exception
     Throws the exception, which must be an instance of a sub-class of
     `<java.lang.Throwable>'.

 -- Syntax: try-finally body handler
     Evaluate body, and return its result.  However, before it returns,
     evaluate handler.  Even if body returns abnormally (by throwing an
     exception), handler is evaluated.

     (This is implemented just like Java's `try'-`finally'.)

 -- Syntax: try-catch body handler ...
     Evaluate body, in the context of the given handler specifications.
     Each handler has the form:

          var type exp ...

     If an exception is thrown in body, the first handler is selected
     such that the thrown exception is an instance of the handler's
     type. If no handler is selected, the exception is propagated
     through the dynamic execution context until a matching handler is
     found.  (If no matching handler is found, then an error message is
     printed, and the computation terminated.)

     Once a handler is selected, the var is bound to the thrown
     exception, and the exp in the handler are executed.  The result of
     the `try-catch' is the result of body if no exception is thrown, or
     the value of the last exp in the selected handler if an exception
     is thrown.

     (This is implemented just like Java's `try'-`catch'.)

 -- Procedure: dynamic-wind in-guard thunk out-guard
     All three arguments must be 0-argument procedures.  First calls
     in-guard, then thunk, then out-guard.  The result of the expression
     is that of thunk.  If thunk is exited abnormally (by throwing an
     exception or invoking a continuation), out-guard is called.

     If the continuation of the dynamic-wind is re-entered (which is not
     yet possible in Kawa), the in-guard is called again.

     This function was added in R5RS.


File: kawa.info,  Node: Eval and Environments,  Next: Debugging,  Prev: Exceptions,  Up: Top

12 Eval and Environments
************************

 -- Procedure: eval expression [environment]
     `eval' evaluates expression in the environment indicated by
     environment.

     The default for environment is the result of
     `(interaction-environment)'.

 -- Procedure: null-environment version
     This procedure returns an environment that contains no variable
     bindings, but contains (syntactic) bindings for all the syntactic
     keywords.

     The effect of assigning to a variable in this environment (such as
     `let') is undefined.

 -- Procedure: scheme-report-environment version
     The version must be an exact non-negative inetger corresponding to
     a version of one of the Revisedversion Reports on Scheme.  The
     procedure returns an environment that contains exactly the set of
     bindings specified in the corresponding report.

     This implementation supports version that is 4 or 5.

     The effect of assigning to a variable in this environment (such as
     `car') is undefined.

 -- Procedure: interaction-environment
     This procedure return an environment that contains
     implementation-defined bindings, as well as top-level user
     bindings.

 -- Procedure: environment-bound? environment symbol
     Return true `#t' if there is a binding for symbol in environment;
     otherwise returns `#f'.

 -- Syntax: fluid-let ((variable init) ...) body ...
     Evaluate the init expressions.  Then modify the dynamic bindings
     for the variables to the values of the init expressions, and
     evaluate the body expressions.  Return the result of the last
     expression in body.  Before returning, restore the original
     bindings.  The temporary bindings are only visible in the current
     thread, and its descendent threads.

 -- Procedure: base-uri [node]
     If node is specified, returns the base-URI property of the node.
     If the node does not have the base-URI property, returns `#f'.
     (The XQuery version returns the empty sequence in that case.)

     In the zero-argument case, returns the "base URI" of the current
     context.  By default the base URI is the current working directory
     (as a URL).  While a source file is `load'ed, the base URI is
     temporarily set to the URL of the document.

 -- Procedure: load path
     The path can be an (absolute) URL or a filename.  Since `load' is a
     run-time function it doesn't work well with Kawa's orientation
     towards compilation.  It is highly recommended that you use instead
     use `*note include: include.'.

 -- Procedure: load-relative path
     Same as `load', except that path is a URI that is relative to the
     context's current base URI.  Since `load-relative' is a run-time
     function it doesn't work well with Kawa's orientation towards
     compilation.  It is highly recommended that you use instead use
     *note include-relative: include-relative.

* Menu:

* Locations::
* Parameter objects::


File: kawa.info,  Node: Locations,  Next: Parameter objects,  Up: Eval and Environments

12.1 Locations
==============

A "location" is a place where a value can be stored.  An "lvalue" is an
expression that refers to a location.  (The name "lvalue" refers to the
fact that the left operand of `set!' is an lvalue.)  The only kind of
lvalue in standard Scheme is a "variable".  Kawa also allows "computed
lvalues".  These are procedure calls used in "lvalue context", such as
the left operand of `set!'.

   You can only use procedures that have an associated "setter".  In
that case, `(set! (f arg ...) value)' is equivalent to `((setter f) arg
... value)' Currently, only a few procedures have associated `setter's,
and only builtin procedures written in Java can have `setter's.

   For example:
     (set! (car x) 10)
   is equivalent to:
     ((setter car) x 10)
   which is equivalent to:
     (set-car! x 10)

 -- Procedure: setter procedure
     Gets the "setter procedure" associated with a "getter procedure".
     Equivalent to `(procedure-property procedure 'setter)'.  By
     convention, a setter procedure takes the same parameters as the
     "getter" procedure, plus an extra parameter that is the new value
     to be stored in the location specified by the parameters.  The
     expectation is that following `((setter proc) args ... value)' then
     the value of `(proc args ...)' will be value.

     The `setter' of `setter' can be used to set the `setter' property.
     For example the Scheme prologue effectively does the following:

          (set! (setter vector-set) vector-set!)

   Kawa also gives you access to locations as first-class values:

 -- Syntax: location lvalue
     Returns a location object for the given lvalue.  You can get its
     value (by applying it, as if it were a procedure), and you can set
     its value (by using `set!' on the application).  The lvalue can be
     a local or global variable, or a procedure call using a procedure
     that has a `setter'.

          (define x 100)
          (define lx (location x))
          (set! (lx) (cons 1 2)) ;; set x to (1 . 2)
          (lx)  ;; returns (1 . 2)
          (define lc (location (car x)))
          (set! (lc) (+ 10 (lc)))
          ;; x is now (11 . 2)

 -- Syntax: define-alias variable lvalue
     Define variable as an alias for lvalue.  In other words, makes it
     so that `(location variable)' is equivalent to `(location lvalue)'.
     This works both top-level and inside a function.

   Some people might find it helpful to think of a location as a
settable "thunk".  Others may find it useful to think of the `location'
syntax as similar to the C `&' operator; for the `*' indirection
operator, Kawa uses procedure application.

   You can use `define-alias' to define a shorter type synonym, similar
to Java's  `import TypeName' (single-type-import) declaration:
     (define-alias StrBuf java.lang.StringBuffer)


File: kawa.info,  Node: Parameter objects,  Prev: Locations,  Up: Eval and Environments

12.2 Parameter objects
======================

A parameter object is a procedure that is bound to a location, and may
optionally have a conversion procedure.  The procedure accepts zero or
one argument.  When the procedure is called with zero arguments, the
content of the location is returned.  On a call with one argument the
content of the location is updated with the result of applying the
parameter object's conversion procedure to the argument.

   Parameter objects are created with the `make-parameter' procedure
which takes one or two arguments. The second argument is a one argument
conversion procedure. If only one argument is passed to make-parameter
the identity function is used as a conversion procedure.  A new location
is created and asociated with the parameter object. The initial content
of the location is the result of applying the conversion procedure to
the first argument of make-parameter.

   Note that the conversion procedure can be used for guaranteeing the
type of the parameter object's binding and/or to perform some conversion
of the value.

   The `parameterize' special form, when given a parameter object and a
value, binds the parameter object to a new location for the dynamic
extent of its body.  The initial content of the location is the result
of applying the parameter object's conversion procedure to the value.
The `parameterize' special form behaves analogously to `let' when
binding more than one parameter object (that is the order of evaluation
is unspecified and the new bindings are only visible in the body of the
parameterize special form).

   When a new thread is created using `future' or `runnable' then the
child thread shares locations with its parents.  This sharing is broken
by a `parameterize' that changes the location, and restored when the
`parameterize' exits.

   Note that `parameterize' and `fluid-let' have similar binding and
sharing behavior.  The difference is that `fluid-let' modifies locations
accessed by name, while `make-parameter' and `parameterize' create
anonymous locations accessed by calling a parameter procedure.

   The R5RS procedures `current-input-port' and `current-output-port'
are parameter objects.

 -- Procedure: make-parameter init [converter]
     Returns a new parameter object which is bound in the global dynamic
     environment to a location containing the value returned by the call
     `(converter init)'. If the conversion procedure converter is not
     specified the identity function is used instead.

     The parameter object is a procedure which accepts zero or one
     argument. When it is called with no argument, the content of the
     location bound to this parameter object in the current dynamic
     environment is returned. When it is called with one argument, the
     content of the location is set to the result of the call
     `(converter arg)', where arg is the argument passed to the
     parameter object, and an unspecified value is returned.

          (define radix
            (make-parameter 10))

          (define write-shared
            (make-parameter
              #f
              (lambda (x)
                (if (boolean? x)
                    x
                    (error "only booleans are accepted by write-shared")))))

          (radix)           ⇒  10
          (radix 2)
          (radix)           ⇒  2
          (write-shared 0)  gives an error

          (define prompt
            (make-parameter
              123
              (lambda (x)
                (if (string? x)
                    x
                    (with-output-to-string (lambda () (write x)))))))

          (prompt)       ⇒  "123"
          (prompt ">")
          (prompt)       ⇒  ">"

 -- Syntax: parameterize ((expr1 expr2) ...) <body>
     The expressions expr1 and expr2 are evaluated in an unspecified
     order. The value of the expr1 expressions must be parameter
     objects. For each expr1 expression and in an unspecified order, the
     local dynamic environment is extended with a binding of the
     parameter object expr1 to a new location whose content is the
     result of the call `(converter val)', where val is the value of
     expr2 and converter is the conversion procedure of the parameter
     object. The resulting dynamic environment is then used for the
     evaluation of <body> (which refers to the R5RS grammar nonterminal
     of that name). The result(s) of the parameterize form are the
     result(s) of the <body>.

          (radix)                                              ⇒  2
          (parameterize ((radix 16)) (radix))                  ⇒  16
          (radix)                                              ⇒  2

          (define (f n) (number->string n (radix)))

          (f 10)                                               ⇒  "1010"
          (parameterize ((radix 8)) (f 10))                    ⇒  "12"
          (parameterize ((radix 8) (prompt (f 10))) (prompt))  ⇒  "1010"


File: kawa.info,  Node: Debugging,  Next: Threads,  Prev: Eval and Environments,  Up: Top

13 Debugging
************

 -- Syntax: trace procedure
     Cause procedure to be "traced", that is debugging output will be
     written to the standard error port every time procedure is called,
     with the parameters and return value.

     Note that Kawa will normally assume that a procedure defined with
     the procedure-defining variant of `define' is constant, and so it
     might be inlined:

          (define (ff x) (list x x))
          (trace ff) ;; probably won't work
          (ff 3)     ;; not traced

     It works if you specify the `--no-inline' flag to Kawa.
     Alternatively, you can use the variable-defining variant of
     `define':

          #|kawa:1|# (define ff (lambda (x) name: 'ff (list x x)))
          #|kawa:2|# (trace ff) ;; works
          #|kawa:3|# (ff 3)
          call to ff (3)
          return from ff => (3 3)
          (3 3)

     Note the use of the `name:' procedure property to give the
     anonymous `lambda' a name.

 -- Syntax: untrace procedure
     Turn off tracing (debugging output) of procedure.

 -- Procedure: disassemble procedure
     Returns a string representation of the disassembled bytecode for
     procedure, when known.


File: kawa.info,  Node: Threads,  Next: Processes,  Prev: Debugging,  Up: Top

14 Threads
**********

There is a very preliminary interface to create parallel threads.  The
interface is similar to the standard `delay'/`force', where a thread is
basically the same as a promise, except that evaluation may be in
parallel.

 -- Syntax: future expression
     Creates a new thread that evaluates expression.

 -- Procedure: force thread
     The standard `force' function has generalized to also work on
     threads.  If waits for the thread's expression to finish executing,
     and returns the result.

 -- Procedure: runnable function
     Creates a new `Runnable' instance from a function.  Useful for
     passing the Java code that expects a `Runnable'.  You can get the
     result (a value or a thrown exception) using the `getResult'
     method.

 -- Procedure: sleep time
     Suspends the current thread for the specified time.  The time can
     be either a pure number (in secords), or a quantity whose unit is a
     time unit (such as `10s').


File: kawa.info,  Node: Processes,  Next: Miscellaneous,  Prev: Threads,  Up: Top

15 Processes
************

 -- Procedure: command-line
     Returns a nonempty list of strings. The first element is an
     implementation-specific name for the running top-level program.
     (For now this is just `"kawa"', but it may become something more
     useful in the future.)  The remaining elements are the command-line
     arguments, as passed to the `main' method.

 -- Variable: command-line-arguments
     Any command-line arguments (following flags processed by Kawa
     itself) are assigned to the global variable
     `command-line-arguments', which is a vector of strings.

 -- Procedure: process-command-line-assignments
     Process any initial command-line options that set variables.  These
     have the form `name=value'.  Any such command-line options (at the
     start of the command-line) are processed and removed from the
     command-line.

          $ kawa -- abc=123 def
          #|kawa:1|# (command-line)
          (kawa abc=123 def)
          #|kawa:2|# (process-command-line-assignments)
          #|kawa:3|# (command-line)
          (kawa def)
          #|kawa:4|# abc
          123

     This function is mostly useful for Kawa applications compiled with
     the `--main' option.  (It is used to set XQuery `external'
     variables.)

 -- Procedure: exit [code]
     Exits the Kawa interpreter, and ends the Java session.  The integer
     value code is returned to the operating system.  If code is not
     specified, zero is returned, indicating normal (non-error)
     termination.  If the code is `#f', it is treated as -1, which means
     an abnormal exit.

 -- Procedure: make-process command envp
     Creates a `<java.lang.Process>' object, using the specified command
     and envp.  The command is converted to an array of Java strings
     (that is an object that has type `<java.lang.String[]>'.  It can be
     a Scheme vector or list (whose elements should be Java strings or
     Scheme strings);  a Java array of Java strings; or a Scheme string.
     In the latter case, the command is converted using `command-parse'.
     The envp is process environment;  it should be either a Java array
     of Java strings, or the special `#!null' value.

 -- Procedure: system command
     Runs the specified command, and waits for it to finish.  Returns
     the return code from the command.  The return code is an integer,
     where 0 conventionally means successful completion.  The command
     can be any of the types handled by `make-process'.

 -- Variable: command-parse
     The value of this variable should be a one-argument procedure.  It
     is used to convert a command from a Scheme string to a Java array
     of the constituent "words".  The default binding, on Unix-like
     systems, returns a new command to invoke `"/bin/sh" "-c"'
     concatenated with the command string; on non-Unix-systems, it is
     bound to `tokenize-string-to-string-array'.

 -- Procedure: tokenize-string-to-string-array command
     Uses a `java.util.StringTokenizer' to parse the command string into
     an array of words.  This splits the command using spaces to delimit
     words; there is no special processing for quotes or other special
     characters.  (This is the same as what
     `java.lang.Runtime.exec(String)' does.)


File: kawa.info,  Node: Miscellaneous,  Next: Input-Output,  Prev: Processes,  Up: Top

16 Miscellaneous
****************

 -- Procedure: scheme-implementation-version
     Returns the Kawa version number as a string.

 -- Variable: home-directory
     A string containing the home directory of the user.

 -- Procedure: scheme-window [shared]
     Create a read-eval-print-loop in a new top-level window.  If shared
     is true, it uses the same environment as the current
     `(interaction-environment)';  if not (the default), a new top-level
     environment is created.

     You can create multiple top-level window that can co-exist.  They
     run in separate threads.

 -- Syntax: when condition form...
     If condition is true, evaluate each form in order, returning the
     value of the last one.

 -- Syntax: unless condition form...
     If condition is false, evaluate each form in order, returning the
     value of the last one.

 -- Procedure: vector-append arg...
     Creates a new vector, containing the elements from all the args
     appended together.   Each arg may be a vector or a list.

 -- Syntax: synchronized object form ...
     Synchronize on the given object.  (This means getting an exclusive
     lock on the object, by acquiring its "monitor".)  Then execute the
     forms while holding the lock.  When the forms finish (normally or
     abnormally by throwing an exception), the lock is released.
     Returns the result of the last form.  Equivalent to the Java
     `synchronized' statement, except that it may return a result.


File: kawa.info,  Node: Input-Output,  Next: Types,  Prev: Miscellaneous,  Up: Top

17 Input, output, and file handling
***********************************

Kawa has a number of useful tools for controlling input and output:

   A programmable reader.

   A powerful pretty-printer.

* Menu:

* Named output formats::
* Paths:: Paths - file name, URLs, and URIs
* Files:: File System Interface
* Resources::
* Ports::
* Format:: Formatted Output (Common-Lisp-style)


File: kawa.info,  Node: Named output formats,  Next: Paths,  Up: Input-Output

17.1 Named output formats
=========================

The `--output-format' (or `--format') command-line switch can be used to
override the default format for how values are printed on the standard
output.  This format is used for values printed by the read-eval-print
interactive interface.  It is also used to control how values are
printed when Kawa evaluates a file named on the command line (using the
`-f' flag or a just a script name).  (It also effects applications
compiled with the `--main' flag.)  It currently effects how values are
printed by a `load', though that may change.

   The default format depends on the current programming language.  For
Scheme, the default is `scheme' for read-eval-print interaction, and
`ignore' for files that are loaded.

   The formats currently supported include the following:
`scheme'
     Values are printed in a format matching the Scheme programming
     language, as if using `display'.  "Groups" or "elements" are
     written as lists.

`readable-scheme'
     Like `scheme', as if using `write': Values are generally printed in
     a way that they can be read back by a Scheme reader.  For example,
     strings have quotation marks, and character values are written like
     `#\A'.

`elisp'
     Values are printed in a format matching the Emacs Lisp programming
     language.  Mostly the same as `scheme'.

`readable-elisp'
     Like `elisp', but values are generally printed in a way that they
     can be read back by an Emacs Lisp reader.  For example, strings
     have quotation marks, and character values are written like `?A'.

`clisp'
`commonlisp'
     Values are printed in a format matching the Common Lisp programming
     language, as if written by `princ'.  Mostly the same as `scheme'.

`readable-clisp'
`readable-commonlisp'
     Like `clisp', but as if written by `prin1': values are generally
     printed in a way that they can be read back by a Common Lisp
     reader.  For example, strings have quotation marks, and character
     values are written like `#\A'.

`xml'
`xhtml'
`html'
     Values are printed in XML, XHTML, or HTML format.  This is
     discussed in more detail in *note Formatting XML::.

`cgi'
     The output should be a follow the CGI standards.  I.e. assume that
     this script is invoked by a web server as a CGI script/program, and
     that the output should start with some response header, followed by
     the actual response data.  To generate the response headers, use
     the `response-header' function.  If the `Content-type' response
     header has not been specified, and it is required by the CGI
     standard, Kawa will attempt to infer an appropriate `Content-type'
     depending on the following value.

`ignore'
     Top-level values are ignored, instead of printed.


File: kawa.info,  Node: Paths,  Next: Resources,  Prev: Named output formats,  Up: Input-Output

17.2 Paths - file name, URLs, and URIs
======================================

A "Path" is the name of a file or some other "resource".  The path
mechanism provides a layer of abstraction, so you can use the same
functions on either a filename or a URL/URI.  Functions that in standard
Scheme take a filename have been generalized to take a path or a path
string, as if using the `path' function below.  For example:
     (open-input-file "http://www.gnu.org/index.html")
     (open-input-file (URI "ftp://ftp.gnu.org/README"))

 -- Type: path
     A general path, which can be a `filename' or a `URI'.  It can be
     either a `filename' or a `URI'.  Represented using the abstract
     Java class `java.text.Path'.

     Coercing a value to a `Path' is equivalent to calling the `path'
     constructor documented below.

 -- Constructor: path arg
     Coerces the arg to a `path'.  If arg is already a `path', it is
     returned unchanged.  If arg is a `java.net.URI', or a
     `java.net.URL' then a `URI' value is returned.  If arg is a
     `java.io.File', a `filepath' value is returned.  Otherwise, arg can
     be a Scheme string or a `java.lang.String'.  A `URI' value is
     returns if the string starts with a URI scheme (such as `"http:"'),
     and a `filepath' value is returned otherwise.

 -- Predicate: path? arg
     True if arg is a `path' - i.e. an instance of a `gnu.text.Path'.

 -- Type: filepath
     The name of a local file.  Represented using the Java class
     `gnu.text.FilePath', which is a wrapper around `java.io.File'.

 -- Predicate: filepath? arg
     True if arg is a `filepath' - i.e. an instance of a
     `gnu.text.FilePath'.

 -- Type: URI
     A Uniform Resource Indicator, which is a generalization of the more
     familiar URL.  The general format is specified by RFC 2396: Uniform
     Resource Identifiers (URI): Generic Syntax
     (http://www.ietf.org/rfc/rfc2396.txt).  Represented using the Java
     class `gnu.text.URIPath', which is a wrapper around `java.net.URI'.
     A URI can be a URL, or it be a relative URI.

 -- Predicate: URI? arg
     True if arg is a `URI' - i.e. an instance of a `gnu.text.URIPath'.

 -- Type: URL
     A Uniform Resource Locator - a subtype of `URI'.  Represented using
     the Java class `gnu.text.URLPath', which is a wrapper around a
     `java.net.URL', in addition to extending `gnu.text.URIPath'.

17.2.1 Extracting Path components
---------------------------------

 -- Procedure: path-scheme arg
     Returns the “URI scheme” of arg (coerced to a `path') if it is
     defined, or `#f' otherwise.  The URI scheme of a `filepath' is
     `"file"' if the `filepath' is absolute, and `#f' otherwise.

          (path-scheme "http://gnu.org/") ⇒ "http"

 -- Procedure: path-authority arg
     Returns the authority part of arg (coerced to a `path') if it is
     defined, or `#f' otherwise.  The “authority” is usually the
     hostname, but may also include user-info or a port-number.

          (path-authority "http://me@localhost:8000/home") ⇒ "me@localhost:8000"

 -- Procedure: path-host arg
     Returns the name name part of arg (coerced to a `path') if it is
     defined, or `#f' otherwise.

          (path-host "http://me@localhost:8000/home") ⇒ "localhost"

 -- Procedure: path-user-info arg
     Returns the “user info” of arg (coerced to a `path') if it is
     specified, or `#f' otherwise.

          (path-host "http://me@localhost:8000/home") ⇒ "me"

 -- Procedure: path-port arg
     Returns the port number of arg (coerced to a `path') if it is
     specified, or `-1' otherwise.  Even if there is a default port
     associated with a URI scheme (such as 80 for `http'), the value -1
     is returned unless the port number is _explictly_ specified.

          (path-host "http://me@localhost:8000/home") ⇒ 8000
          (path-host "http://me@localhost/home") ⇒ -1

 -- Procedure: path-file arg
     Returns the “path component” of the arg (coerced to a `path').
     (The name `path-path' might be more logical, but it is obviously a
     bit awkward.)  The path component of a file name is the file name
     itself.  For a URI, it is the main hierarchical part of the URI,
     without schema, authority, query, or fragment.

          (path-file "http://gnu.org/home/me.html?add-bug#body") ⇒ "/home/me.html"

 -- Procedure: path-directory arg
     If arg (coerced to a `path') is directory, return arg; otherwise
     return the “parent” path, without the final component.

          (path-directory "http://gnu.org/home/me/index.html#body")
            ⇒ (path "http://gnu.org/home/me/")
          (path-directory "http://gnu.org/home/me/")
            ⇒ (path "http://gnu.org/home/me/")

     `(path-directory "./dir")' `⇒' `(path "./dir")' if `dir' is a
     directory, and `(path ".")' otherwise.

 -- Procedure: path-parent arg
     Returns the “parent directory” of arg (coerced to a `path').  If
     arg is not a directory, same as `path-directory arg'.

          (path-parent "a/b/c") ⇒ (path "a/b")
          (path-parent "file:/a/b/c") ⇒ (path "file:/a/b/c")
          (path-parent "file:/a/b/c/") ⇒ (path "file:/a/b/")

 -- Procedure: path-last arg
     The last component of path component of arg (coerced to a `path').
     Returns a substring of `(path-file arg)'.  If that string ends with
     `/' or the path separator, that last character is ignored.  Returns
     the tail of the path-string, following the last (non-final) `/' or
     path separator.

          (path-last "http:/a/b/c") ⇒ "c"
          (path-last "http:/a/b/c/") ⇒ "c"
          (path-last "a/b/c") ⇒ "c"

 -- Procedure: path-extension arg
     Returns the “extension” of the arg (coerced to a `path').

          (path-extension "http://gnu.org/home/me.html?add-bug#body") ⇒ "html"
          (path-extension "/home/.init") ⇒ #f

 -- Procedure: path-query arg
     Returns the query part of arg (coerced to a `path') if it is
     defined, or `#f' otherwise.  The query of a URI is the part of
     after `?'.

          (path-query "http://gnu.org/home?add-bug") ⇒ "add-bug"

 -- Procedure: path-fragment arg
     Returns the fragment part of arg (coerced to a `path') if it is
     defined, or `#f' otherwise.  The fragment of a URI is the part of
     after `#'.

          (path-query "http://gnu.org/home#top") ⇒ "top"

 -- Procedure: resolve-uri uri base
     Returns a uri unchanged if it is an absolute URI.  Otherwise
     resolves it against a base URI base, which is normally (though not
     always) absolute.


File: kawa.info,  Node: Resources,  Next: Files,  Prev: Paths,  Up: Input-Output

17.3 Resources
==============

A resource is a file or other fixed data that an application may access.
Resources are part of the application and are shipped with it, but are
stored in external files.  Examples are images, sounds, and translation
(localization) of messages.  In the Java world a resource is commonly
bundled in the same jar file as the application itself.

 -- Syntax: resource-url resource-name
     Returns a `URLPath' you can use as a `URL', or you can pass to it
     `open-input-file' to read the resource data.  The resource-name is
     a string which is passed to the `ClassLoader' of the containing
     module.  If the module class is in a jar file, things will
     magically work if the resource is in the same jar file, and
     resource-name is a filename relative to the module class in the
     jar.  If the module is immediately evaluated, the resource-name is
     resolved against the location of the module source file.

 -- Syntax: module-uri
     Evaluates to a special URI that can be used to access resources
     relative to the class of the containing module.  The URI has the
     form `"class-resource://CurrentClass/"' in compiled code, to allow
     moving the classes/jars.  The current `ClassLoader' is associated
     with the URI, so accessing resources using the URI will use that
     `ClassLoader'.  Therefore you should not create a
     `"class-resource:"' URI except by using this function or
     `resolve-uri', since that might try to use the wrong `ClassLoader'.

     The macro `resource-url' works by using `module-uri' and resolving
     that to a normal `URL'.


File: kawa.info,  Node: Files,  Next: Ports,  Prev: Resources,  Up: Input-Output

17.4 File System Interface
==========================

 -- Procedure: file-exists? filename
     Returns true iff the file named filename actually exists.  This
     function is defined on arbitrary `path' values: for URI values we
     open a `URLConnection' and invoke `getLastModified()'.

 -- Procedure: file-directory? filename
     Returns true iff the file named filename actually exists and is a
     directory.  This function is defined on arbitrary `path' values;
     the default implementation for non-file objects is to return `#t'
     iff the path string ends with the character `/'.

 -- Procedure: file-readable? filename
     Returns true iff the file named filename actually exists and can be
     read from.

 -- Procedure: file-writable? filename
     Returns true iff the file named filename actually exists and can be
     writen to.  (Undefined if the filename does not exist, but the file
     can be created in the directory.)

 -- Procedure: delete-file filename
     Delete the file named filename.  On failure, throws an exception.

 -- Procedure: rename-file oldname newname
     Renames the file named oldname to newname.

 -- Procedure: copy-file oldname newname-from path-to
     Copy the file named oldname to newname.  The return value is
     unspecified.

 -- Procedure: create-directory dirname
     Create a new directory named dirname.  Unspecified what happens on
     error (such as exiting file with the same name).  (Currently
     returns `#f' on error, but may change to be more compatible with
     scsh.)

 -- Procedure: system-tmpdir
     Return the name of the default directory for temporary files.

 -- Procedure: make-temporary-file [format]
     Return a file with a name that does not match any existing file.
     Use format (which defaults to `"kawa~d.tmp"') to generate a unique
     filename in `(system-tmpdir)'.  The current implementation is _not_
     safe from race conditions; this will be fixed in a future release
     (using Java2 features).


File: kawa.info,  Node: Ports,  Next: Format,  Prev: Files,  Up: Input-Output

17.5 Ports
==========

 -- Procedure: current-error-port
     Return the port to which errors and warnings should be sent (the
     "standard error" in Unix and C terminology).

 -- Procedure: read-line [port [handle-newline]]
     Reads a line of input from port.  The handle-newline parameter
     determines what is done with terminating end-of-line delimiter.
     The default, `'trim', ignores the delimiter; `'peek' leaves the
     delimiter in the input stream; `'concat' appends the delimiter to
     the returned value; and `'split' returns the delimiter as a second
     value.  You can use the last three options to tell if the string
     was terminated by end-or-line or by end-of-file.

 -- Procedure: open-input-string string
     Takes a string and returns an input port that delivers characters
     from the string. The port can be closed by `close-input-port',
     though its storage will be reclaimed by the garbage collector if it
     becomes inaccessible.

          (define p
            (open-input-string "(a . (b c . ())) 34"))

          (input-port? p)                 ⇒  #t
          (read p)                        ⇒  (a b c)
          (read p)                        ⇒  34
          (eof-object? (peek-char p))     ⇒  #t

 -- Procedure: open-output-string
     Returns an output port that will accumulate characters for
     retrieval by `get-output-string'.  The port can be closed by the
     procedure `close-output-port', though its storage will be reclaimed
     by the garbage collector if it becomes inaccessible.

          (let ((q (open-output-string))
            (x '(a b c)))
              (write (car x) q)
              (write (cdr x) q)
              (get-output-string q))        ⇒  "a(b c)"

 -- Procedure: get-output-string output-port
     Given an output port created by `open-output-string', returns a
     string consisting of the characters that have been output to the
     port so far.

 -- Procedure: call-with-input-string string proc
     Create an input port that gets its data from string, call proc with
     that port as its one argument, and return the result from the call
     of proc

 -- Procedure: call-with-output-string proc
     Create an output port that writes its data to a string, and call
     proc with that port as its one argument.  Return a string
     consisting of the data written to the port.

 -- Procedure: force-output [port]
     Forces any pending output on port to be delivered to the output
     device and returns an unspecified value.  If the port argument is
     omitted it defaults to the value returned by
     `(current-output-port)'.

   An interactive input port has a prompt procedure associated with it.
The prompt procedure is called before a new line is read.  It is passed
the port as an argument, and returns a string, which gets printed as a
prompt.

 -- Procedure: input-port-prompter port
     Get the prompt procedure associated with port.

 -- Procedure: set-input-port-prompter! port prompter
     Set the prompt procedure associated with port to prompter, which
     must be a one-argument procedure taking an input port, and
     returning a string.

 -- Procedure: default-prompter port
     The default prompt procedure.  It returns `"#|kawa:L|# "', where L
     is the current line number of port.  When reading a continuation
     line, the result is `"#|C---:L|# "', where `C' is the character
     returned by `(input-port-read-state port)'.  The prompt has the
     form of a comment to make it easier to cut-and-paste.

 -- Function: port-column input-port
 -- Function: port-line input-port
     Return the current column number or line number of input-port,
     using the current input port if none is specified.  If the number
     is unknown, the result is `#f'.  Otherwise, the result is a
     0-origin integer - i.e. the first character of the first line is
     line 0, column 0.  (However, when you display a file position, for
     example in an error message, we recommend you add 1 to get 1-origin
     integers.  This is because lines and column numbers traditionally
     start with 1, and that is what non-programmers will find most
     natural.)

 -- Procedure: set-port-line! port line
     Set (0-origin) line number of the current line of port to num.

 -- Procedure: input-port-line-number port
     Get the line number of the current line of port, which must be a
     (non-binary) input port.  The initial line is line 1.  Deprecated;
     replaced by `(+ 1 (port-line port))'.

 -- Procedure: set-input-port-line-number! port num
     Set line number of the current line of port to num.  Deprecated;
     replaced by `(set-port-line! port (- num 1))'.

 -- Procedure: input-port-column-number port
     Get the column number of the current line of port, which must be a
     (non-binary) input port.  The initial column is column 1.
     Deprecated; replaced by `(+ 1 (port-column port))'.

 -- Procedure: input-port-read-state port
     Returns a character indicating the current `read' state of the
     port.  Returns `#\Return' if not current doing a read, `#\"' if
     reading a string;  `#\|' if reading a comment;  `#\(' if inside a
     list; and `#\Space' when otherwise in a `read'.  The result is
     intended for use by prompt prcedures, and is not necessarily
     correct except when reading a new-line.

 -- Variable: symbol-read-case
     A symbol that controls how `read' handles letters when reading a
     symbol.  If the first letter is `U', then letters in symbols are
     upper-cased.  If the first letter is `D' or `L', then letters in
     symbols are down-cased.  If the first letter is `I', then the case
     of letters in symbols is inverted.  Otherwise (the default), the
     letter is not changed.  (Letters following a `\' are always
     unchanged.)

 -- Variable: port-char-encoding
     Controls how bytes in external files are converted to/from internal
     Unicode characters.  Can be either a symbol or a boolean.  If
     `port-char-encoding' is `#f', the file is assumed to be a binary
     file and no conversion is done.  Otherwise, the file is a text
     file.  The default is `#t', which uses a locale-dependent
     conversion.  If `port-char-encoding' is a symbol, it must be the
     name of a character encoding known to Java.  For all text files
     (that is if `port-char-encoding' is not `#f'), on input a
     `#\Return' character or a `#\Return' followed by `#\Newline' are
     converted into plain `#\Newline'.

     This variable is checked when the file is opened;  not when
     actually reading or writing.  Here is an example of how you can
     safely change the encoding temporarily:

          (define (open-binary-input-file name)
            (fluid-let ((port-char-encoding #f)) (open-input-file name)))

 -- Variable: *print-base*
     The number base (radix) to use by default when printing rational
     numbers.  Must be an integer between 2 and 36, and the default is
     of course 10.  For example setting `*print-base*' to 16 produces
     hexadecimal output.

 -- Variable: *print-radix*
     If true, prints an indicator of the radix used when printing
     rational numbers.  If `*print-base*' is respectively 2, 8, or 16,
     then `#b', `#o' or `#x' is written before the number; otherwise
     `#Nr' is written, where `N' is the base.  An exception is when
     `*print-base*' is 10, in which case a period is written _after_ the
     number, to match Common Lisp; this may be inappropriate for Scheme,
     so is likely to change.

 -- Variable: *print-right-margin*
     The right margin (or line width) to use when pretty-printing.

 -- Variable: *print-miser-width*
     If this an integer, and the available width is less or equal to
     this value, then the pretty printer switch to the more "miser"
     compact style.


File: kawa.info,  Node: Format,  Prev: Ports,  Up: Input-Output

17.6 Formatted Output (Common-Lisp-style)
=========================================

 -- Procedure: format destination fmt . arguments
     An almost complete implementation of Common LISP format description
     according to the CL reference book `Common LISP' from Guy L.
     Steele, Digital Press.  Backward compatible to most of the
     available Scheme format implementations.

     Returns `#t', `#f' or a string; has side effect of printing
     according to fmt.  If destination is `#t', the output is to the
     current output port and `#!void' is returned.  If destination is
     `#f', a formatted string is returned as the result of the call.  If
     destination is a string, destination is regarded as the format
     string; fmt is then the first argument and the output is returned
     as a string. If destination is a number, the output is to the
     current error port if available by the implementation. Otherwise
     destination must be an output port and `#!void' is returned.

     fmt must be a string or an instance of `gnu.text.MessageFormat' or
     `java.text.MessageFormat'.  If fmt is a string, it is parsed as if
     by `parse-format'.

 -- Procedure: parse-format format-string
     Parses `format-string', which is a string of the form of a Common
     LISP format description.  Returns an instance of
     `gnu.text.ReportFormat', which can be passed to the `format'
     function.

   A format string passed to `format' or `parse-format' consists of
format directives (that start with `~'), and regular characters (that
are written directly to the destination).  Most of the Common Lisp (and
Slib) format directives are implemented.  Neither justification, nor
pretty-printing are supported yet.

   Plus of course, we need documentation for `format'!

17.6.1 Implemented CL Format Control Directives
-----------------------------------------------

Documentation syntax: Uppercase characters represent the corresponding
control directive characters. Lowercase characters represent control
directive parameter descriptions.

`~A'
     Any (print as `display' does).

     `~@A'
          left pad.

     `~mincol,colinc,minpad,padcharA'
          full padding.

`~S'
     S-expression (print as `write' does).

     `~@S'
          left pad.

     `~mincol,colinc,minpad,padcharS'
          full padding.

`~C'
     Character.

     `~@C'
          prints a character as the reader can understand it (i.e. `#\'
          prefixing).

     `~:C'
          prints a character as emacs does (eg. `^C' for ASCII 03).

17.6.2 Formatting Integers
--------------------------

`~D'
     Decimal.

     `~@D'
          print number sign always.

     `~:D'
          print comma separated.

     `~mincol,padchar,commachar,commawidthD'
          padding.

`~X'
     Hexadecimal.

     `~@X'
          print number sign always.

     `~:X'
          print comma separated.

     `~mincol,padchar,commachar,commawidthX'
          padding.

`~O'
     Octal.

     `~@O'
          print number sign always.

     `~:O'
          print comma separated.

     `~mincol,padchar,commachar,commawidthO'
          padding.

`~B'
     Binary.

     `~@B'
          print number sign always.

     `~:B'
          print comma separated.

     `~mincol,padchar,commachar,commawidthB'
          padding.

`~nR'
     Radix n.

     `~n,mincol,padchar,commachar,commawidthR'
          padding.

`~@R'
     print a number as a Roman numeral.

`~:@R'
     print a number as an “old fashioned” Roman numeral.

`~:R'
     print a number as an ordinal English number.

`~R'
     print a number as a cardinal English number.

`~P'
     Plural.

     `~@P'
          prints `y' and `ies'.

     `~:P'
          as `~P but jumps 1 argument backward.'

     `~:@P'
          as `~@P but jumps 1 argument backward.'

   commawidth is the number of characters between two comma characters.

17.6.3 Formatting real numbers
------------------------------

`~F'
     Fixed-format floating-point (prints a flonum like mmm.nnn).

     `~width,digits,scale,overflowchar,padcharF'

     `~@F'
          If the number is positive a plus sign is printed.

`~E'
     Exponential floating-point (prints a flonum like mmm.nnn`E'ee)

     `~width,digits,exponentdigits,scale,overflowchar,padchar,exponentcharE'

     `~@E'
          If the number is positive a plus sign is printed.

`~G'
     General floating-point (prints a flonum either fixed or
     exponential).

     `~width,digits,exponentdigits,scale,overflowchar,padchar,exponentcharG'

     `~@G'
          If the number is positive a plus sign is printed.

     A slight difference from Common Lisp:  If the number is printed in
     fixed form and the fraction is zero, then a zero digit is printed
     for the fraction, if allowed by the width and digits is
     unspecified.

`~$'
     Dollars floating-point (prints a flonum in fixed with signs
     separated).

     `~digits,scale,width,padchar$'

     `~@$'
          If the number is positive a plus sign is printed.

     `~:@$'
          A sign is always printed and appears before the padding.

     `~:$'
          The sign appears before the padding.

17.6.4 Miscellaneous formatting operators
-----------------------------------------

`~%'
     Newline.

     `~n%'
          print n newlines.

`~&'
     print newline if not at the beginning of the output line.

     `~n&'
          prints `~&' and then n-1 newlines.

`~|'
     Page Separator.

     `~n|'
          print n page separators.

`~~'
     Tilde.

     `~n~'
          print n tildes.

`~'<newline>
     Continuation Line.

     `~:'<newline>
          newline is ignored, white space left.

     `~@'<newline>
          newline is left, white space ignored.

`~T'
     Tabulation.

     `~@T'
          relative tabulation.

     `~colnum,colincT'
          full tabulation.

`~?'
     Indirection (expects indirect arguments as a list).

     `~@?'
          extracts indirect arguments from format arguments.

`~(str~)'
     Case conversion (converts by `string-downcase').

     `~:(str~)'
          converts by `string-capitalize'.

     `~@(str~)'
          converts by `string-capitalize-first'.

     `~:@(str~)'
          converts by `string-upcase'.

`~*'
     Argument Jumping (jumps 1 argument forward).

     `~n*'
          jumps n arguments forward.

     `~:*'
          jumps 1 argument backward.

     `~n:*'
          jumps n arguments backward.

     `~@*'
          jumps to the 0th argument.

     `~n@*'
          jumps to the nth argument (beginning from 0)

`~[str0~;str1~;...~;strn~]'
     Conditional Expression (numerical clause conditional).

     `~n['
          take argument from n.

     `~@['
          true test conditional.

     `~:['
          if-else-then conditional.

     `~;'
          clause separator.

     `~:;'
          default clause follows.

`~{str~}'
     Iteration (args come from the next argument (a list)).

     `~n{'
          at most n iterations.

     `~:{'
          args from next arg (a list of lists).

     `~@{'
          args from the rest of arguments.

     `~:@{'
          args from the rest args (lists).

`~^'
     Up and out.

     `~n^'
          aborts if n = 0

     `~n,m^'
          aborts if n = m

     `~n,m,k^'
          aborts if n <= m <= k

17.6.5 Unimplemented CL Format Control Directives
-------------------------------------------------

`~:A'
     print `#f' as an empty list (see below).

`~:S'
     print `#f' as an empty list (see below).

`~<~>'
     Justification.

`~:^'

17.6.6 Extended, Replaced and Additional Control Directives
-----------------------------------------------------------

These are not necesasrily implemented in Kawa!

`~I'
     print a R4RS complex number as `~F~@Fi' with passed parameters for
     `~F'.

`~Y'
     Pretty print formatting of an argument for scheme code lists.

`~K'
     Same as `~?.'

`~!'
     Flushes the output if format destination is a port.

`~_'
     Print a `#\space' character

     `~n_'
          print n `#\space' characters.

`~nC'
     Takes n as an integer representation for a character. No arguments
     are consumed. n is converted to a character by `integer->char'.  n
     must be a positive decimal number.

`~:S'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~:A'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~F, ~E, ~G, ~$'
     may also print number strings, i.e. passing a number as a string
     and format it accordingly.


File: kawa.info,  Node: Types,  Next: Objects Classes and Modules,  Prev: Input-Output,  Up: Top

18 Types
********

A "type" is a set of values, plus an associated set of operations valid
on those values.  Types are useful for catching errors
("type-checking"), documenting the programmer's intent, and to help the
compiler generate better code.  Types in some languages (such as C)
appear in programs, but do not exist at run-time.  In such languages,
all type-checking is done at compile-time.  Other languages (such as
standard Scheme) do not have types as such, but they have "predicates",
which allow you to check if a value is a member of certain sets;  also,
the primitive functions will check at run-time if the arguments are
members of the allowed sets.  Other languages, including Java and Common
Lisp, provide a combination:  Types may be used as specifiers to guide
the compiler, but also exist as actual run-time values.  In Java, for
each class, there is a corresponding `java.lang.Class' run-time object,
as well as an associated type (the set of values of that class, plus its
sub-classes, plus `null').

   Kawa, like Java, has first-class types, that is types exist as
objects you can pass around at run-time.  For each Java type, there is a
corresponding Kawa type (but not necessarily vice versa).  It would be
nice if we could represent run-time type values using `java.lang.Class'
objects, but unfortunately that does not work very well.  One reason is
that we need to be able to refer to types and classes that do not exist
yet, because we are in the processing of compiling them.  Another reason
is that we want to be able to distinuish between different types that
are implemented using the same Java class.

   Various Kawa constructs require or allow a type to be specified.
Those specifications consist of "type expressions", which is evaluated
to yield a type value.  The current Kawa compiler is rather
simple-minded, and in many places only allows simple types that the
compiler can evaluate at compile-time.  More specifically, it only
allows simple "type names" that map to primitive Java types or java
classes.

* Menu:

* Standard Types::
* Declaring Types of Variables::
* Type tests and conversions::


File: kawa.info,  Node: Standard Types,  Next: Declaring Types of Variables,  Up: Types

18.1 Standard Types
===================

These types are predefined with the following names.

   Instead if plain `typename' you can also use the syntax `<typename>'
with angle brackets, but that syntax is no longer recommended, because
it doesn't “fit” as well with some ways type names are used.

   To find which Java classes these types map into, look in
`kawa/standard/Scheme.java'.

   Note that the value of these variables are instances of
`gnu.bytecode.Type', not (as you might at first expect)
`java.lang.Class'.

 -- Variable: Object
     An arbitrary Scheme value - and hence an arbitrary Java object.

 -- Variable: number
     The type of Scheme numbers.

 -- Variable: quantity
     The type of quantities optionally with units.  This is a sub-type
     of `number'.

 -- Variable: complex
     The type of complex numbers.  This is a sub-type of `quantity'.

 -- Variable: real
     The type of real numbers.  This is a sub-type of `complex'.

 -- Variable: rational
     The type of exact rationl numbers.  This is a sub-type of `real'.

 -- Variable: integer
     The type of exact Scheme integers.  This is a sub-type of
     `rational'.

 -- Variable: symbol
     The type of Scheme symbols.  (Implemented using the Java class
     `gnu.mapping.Symbol'.)  (Compatibility note: Previous versions of
     Kawa implemented a simple Scheme symbol using an interned
     `java.lang.String'.)

 -- Variable: keyword
     The type of keyword values.  *Note Keywords::.

 -- Variable: list
     The type of Scheme lists (pure and impure, including the empty
     list).

 -- Variable: pair
     The type of Scheme pairs.  This is a sub-type of `list'.

 -- Variable: string
     The type of Scheme strings.  (Implemented using `java.lang.String'
     for immutable strings, and `gnu.lists.FString' for mutable strings.
     Both of these implement the interface `java.lang.CharSequence'.  In
     the future, we may change the representation for strings containing
     “surrogate characters”, for efficient indexing.)  (Compatibility
     note: Previous versions of Kawa implemented always used
     `gnu.lists.FString'.)

 -- Variable: character
     The type of Scheme character values.  This is a sub-type of
     `Object', in contrast to type `char', which is the primitive Java
     `char' type.

 -- Variable: vector
     The type of Scheme vectors.

 -- Variable: procedure
     The type of Scheme procedures.

 -- Variable: input-port
     The type of Scheme input ports.

 -- Variable: output-port
     The type of Scheme output ports.

 -- Variable: String
     This type name is a special case.  It specifies the class
     `java.lang.String'.  However, coercing a value to `String' is done
     by invoking the `toString' method on the value to be coerced.  Thus
     it "works" for all objects.  It also works for `#!null'.

     When Scheme code invokes a Java methods any parameter whose type is
     `java.lang.String' is converted as if it was declared as a
     `String'.

   More will be added later.

   A type specifier can also be one of the primitive Java types.  The
numeric types `long', `int', `short', `byte', `float', and `double' are
converted from the corresponding Scheme number classes.  Similarly,
`char' can be converted to and from Scheme characters.  The type
`boolean' matches any object, and the result is `false' if and only if
the actual argument is `#f'.  (The value `#f' is identical to
`Boolean.FALSE', and `#t' is identical to `Boolean.TRUE'.)  The return
type `void' indicates that no value is returned.

   A type specifier can also be a fully-qualified Java class name (for
example `java.lang.StringBuffer').  In that case, the actual argument is
cast at run time to the named class.  Also, `java.lang.StringBuffer[]'
represents an array of references to `java.lang.StringBuffer' objects.


File: kawa.info,  Node: Declaring Types of Variables,  Next: Type tests and conversions,  Prev: Standard Types,  Up: Types

18.2 Declaring Types of Variables
=================================

 -- Syntax: let `(('name [`::' type] init`)' ...`)' body
     Declare new locals variables with the given name, initial value
     init, and optional type specification type.  If type is specified,
     then the expression init is evaluated, the result coerced to type,
     and then assigned to the variable.  If type is not specified, it
     defaults to `Object'.

 -- Syntax: let* `(('name [`::' type] init`)' ...`)' body

 -- Syntax: letrec `(('name [`::' type] init`)' ...`)' body

 -- Syntax: define [`::' type] value

   See also `define-private', and `define-constant'.


File: kawa.info,  Node: Type tests and conversions,  Prev: Declaring Types of Variables,  Up: Types

18.3 Type tests and conversions
===============================

Scheme defines a number of standard type testing predicates.  For
example `(vector? x)' is `#t' if and only if `x' is a vector.

   Kawa generalizes this to arbitrary type names: If T is a type-name
(that is in scope at compile-time), then `T?' is a one-argument function
that returns `#t' if the argument is an instance of the type `T', and
`#f' otherwise:
     (gnu.lists.FVector? #(123)) ⇒ #t
     (let ((iarr (int[] 10))) (int[]? iarr)) ⇒ #t 
   In general:
     (T? x) ⇒ (instance? x T)

 -- Procedure: instance? value type
     Returns `#t' iff value is an instance of type type.  (Undefined if
     type is a primitive type, such as `int'.)

 -- Procedure: as type value
     Converts or coerces value to a value of type type.  Throws an
     exception if that cannot be done.  Not supported for type to be a
     primitive type such as `<int>'.


File: kawa.info,  Node: Objects Classes and Modules,  Next: XML tools,  Prev: Types,  Up: Top

19 Object, Classes and Modules
******************************

Kawa provides various ways to define, create, and access Java objects.
Here are the currently supported features.

   The Kawa module system is based on the features of the Java class
system.

* Menu:

* Defining new classes::
* Anonymous classes::
* Enumerations::          Enumeration types
* Module classes::        Modules and how they are compiled to classes
* Record types::          Defining Record Types
* Dynamic records::       Creating New Record Types On-the-fly
* Method operations::     Calling Java methods from Scheme
* Allocating objects::
* Field operations::      Accessing fields of Java objects
* Mangling::              Mapping Scheme names to Java names
* Scheme types in Java::
* Array operations::      Using Java arrays
* Loading Java functions into Scheme::
* Evaluating Scheme expressions from Java::

 -- Syntax: this
     Returns the "this object" - the current instance of the current
     class.  The current implementation is incomplete, not robust, and
     not well defined.  However, it will have to do for now.  Note:
     "`this'" is a macro, not a variable, so you have to write it using
     parentheses: `(this)'.  A planned extension will allow an optional
     class specifier (needed for nested clases).


File: kawa.info,  Node: Defining new classes,  Next: Anonymous classes,  Up: Objects Classes and Modules

19.1 Defining new classes
=========================

Kawa provides various mechanisms for defining new classes.  The
`define-class' and `define-simple-class' forms will usually be the
preferred mechanisms.  They have basically the same syntax, but have a
couple of differences.  `define-class' allows multiple inheritance as
well as true nested (first-class) class objects.  However, the
implementation is more complex: code using it is slightly slower, and
the mapping to Java classes is a little less obvious.   (Each Scheme
class is implemented as a pair of an interface and an implementation
class.)  A class defined by `define-simple-class' is slightly more
efficient, and it is easier to access it from Java code.

   The syntax of `define-class' are mostly compatible with that in the
Guile and Stk dialects of Scheme.

 -- Syntax: define-class name `('supers ...`)' option-pair*
          field-or-method-decl ...
 -- Syntax: define-simple-class name `('supers ...`)' option-pair*
          field-or-method-decl ...

          option-pair `::=' option-keyword option-value
          field-or-method-decl `::=' field-decl | method-decl

     Defines a new class named name.  If `define-simple-class' is used,
     creates a normal Java class named name in the current package.  (If
     name has the form `<xyx>' the Java implementation type is named
     `xyz'.)  For `define-class' the implementation is unspecified.  In
     most cases, the compiler creates a class pair, consisting of a Java
     interface and a Java implementation class.

19.1.1 General class properties
-------------------------------

The class inherits from the classes and interfaces listed in supers.
This is a list of names of classes that are in scope (perhaps imported
using `require'), or names for existing classes or interfaces optionally
surrounded by `<>', such as `<gnu.lists.Sequence>'.  If
`define-simple-class' is used, at most one of these may be the name of a
normal Java class or classes defined using `define-simple-class'; the
rest must be interfaces or classes defined using `define-class'.  If
`define-class' is used, _all_ of the classes listed in supers should be
interfaces or classes defined using `define-class'.

`interface:' make-interface
     Specifies whether Kawa generates a Java class, interface, or both.
     If make-interface is `#t', then a Java interface is generated.  In
     that case all the supertypes must be interfaces, and all the
     declared methods must be abstract.  If make-interface is `#f', then
     a Java class is generated.  If `interface:'  is unspecified, the
     default is `#f' for `define-simple-class'.  For `define-class' the
     default is to generate an interface, and in addition (if needed) a
     helper class that implements the interface.  (In that case any
     non-abstract methods are compiled to static methods.  The methods
     that implement the interface are just wrapper methods that call the
     real static methods.  This allows Kawa to implement true multiple
     inheritance.)

`access:' kind
     Specifies the Java access permission on the class.  Can be one of
     `'public' (which is the default in Kawa), `'package' (which the
     default "unnamed" permission in Java code), `'protected',
     `'private', `'volatile', or `'transient'.  Can also be used to
     specify `final' or `enum', as in Java.  Can also be a list, as for
     example:

          access: '(protected volatile)

`class-name:' `"'cname`"'
     Specifies the Java name of the created class.  The name specified
     after `define-class' or `define-simple-class' is the _Scheme name_,
     i.e. the name of a Scheme variable that is bound to the class.  The
     Java name is by default derived from the Scheme name, but you can
     override the default with a `class-name:' specifier.  If the cname
     has no periods, then it is a name in the package of the main
     (module) class.  If the cname starts with a period, then you get a
     class nested within the module class.  In this case the actual
     class name is moduleClass`$'rname, where rname is cname without the
     initial period.  To force a class in the top-level (unnamed)
     package (something not recommended) write a period at the end of
     the cname.

19.1.2 Declaring fields
-----------------------

     field-decl `::=' `('fname [`::' ftype] option-pair*`)'

   Each field-decl declares a instance "slot" (field) with the given
fname.  By default it is publicly visible, but you can specify a
different visiblity with the `access:' specifier.   If ftype is
specified it is the type of the slot.  The following option-keywords are
implemented:
`type:' ftype
     Specifies that ftype is the type of (the values of) the field.
     Equivalent to `:: ftype'.

`allocation:' kind
     If kind is `'class' or `'static' a single slot is shared between
     all instances of the class (and its sub-classes).  Not yet
     implemented for `define-class', only for `define-simple-class'.  In
     Java terms this is a `static' field.

     If kind is `'instance' then each instance has a separate value
     "slot", and they are not shared. In Java terms, this is a
     non-`static' field.  This is the default.

`access:' kind
     Specifies the Java access permission on the field.  Can be one of
     `'private', `'protected', `'public' (which is the default in Kawa),
     or `'package' (which the default "unnamed" permission in Java
     code).  Can also be used to specify `volatile', `transient',
     `enum', or `final', as in Java.

`init:' expr
     An expression used to initialize the slot.  The expression is
     evaluated in a scope that includes the field and method names of
     the current class.

`init-form:' expr
     An expression used to initialize the slot.  The lexical environment
     of the expr is that of the `define-class'; it does _not_ include
     the field and method names of the current class.  or
     `define-simple-class'.

`init-value:' value
     A value expression used to initialize the slot.  For now this is
     synonymous with init-form:, but that may change (depending on what
     other implementation do), so to be safe only use `init-value:' with
     a literal.

`init-keyword:' `name:'
     A keyword that that can be used to initialize instance in `make'
     calls.  For now, this is ignored, and name should be the same as
     the field's fname.

   The fname can be left out.  That indicates a "dummy slot", which is
useful for initialization not tied to a specific field.  In this
example, `x' is the only actual field.  It is first initialized to 10,
but if `(some-condition)' is true then its value is doubled.
     (define-simple-class <my-class> ()
       (allocation: 'class
        init: (perform-actions-when-the-class-is-initizalized))
       (x init: 10)
       (init: (if (some-condition) (set! x (* x 2)))))

19.1.3 Declaring methods
------------------------

     method-decl `::=' `(('method-name formal-arguments `)' `::' rtype] option-pair* body`)'

   Each method-decl declares a method, which is by default public and
non-static, and whose name is method-name.  (If method-name is not a
valid Java method name, it is mapped to something reasonable.  For
example `foo-bar?' is mapped to `isFooBar'.)  The types of the method
arguments can be specified in the formal-arguments.  The return type can
be specified by rtype, or is otherwise the type of the body.  Currently,
the formal-arguments cannot contain optional, rest, or keyword
parameters.  (The plan is to allow optional parameters, implemented
using multiple overloaded methods.)

   A method-decl in a `define-simple-class' can have the following
option-keywords:
`access:' kind
     Specifies the Java access permission on the method.  Can be one of
     `'private', `'protected', `'public', or `'package'.

`allocation:' kind
     If kind is `'class' or `'static' creates a static method.

`throws:' ( exception-class-name ... )
     Specifies a list of checked exception that the method may throw.
     Equivalent to a `throws' specification in Java code.  For example:

          (define-simple-class T
            (prefix)
            ((lookup name) throws: (java.io.FileNotFoundException)
             (make java.io.FileReader (string-append prefix name))))

   The scope of the body of a method includes the field-decls and
field-decls of the body, including those inherited from superclasses and
implemented interfaces.

   If the body is the special form `#!abstract', then the method is
abstract.  This means the method must be overridden in a subclass, and
you're not allowed to create an instance of the enclosing class.

     (define-simple-class Searchable () interface: #t
       ((search value) :: boolean #!abstract))

   The special method-name `*init*' can be used to name a non-default
constructor (only if make-interface discussed above is `#f').  It can be
used to initialize a freshly-allocated instance using passed-in
parameters.  You can call a superclass or a sibling constructor using
the `invoke-special' special function.  (This is general but admittedly
a bit verbose; a more compact form may be added in the future.)  See the
example below.

19.1.4 Example
--------------

In the following example we define a simple class `2d-vector' and a
class `3d-vector' that extends it.  (This is for illustration only -
defining 3-dimensional points as an extension of 2-dimensional points
does not really make sense.)

     (define-simple-class 2d-vector ()
       (x ::double init-keyword: x:)
       ;; Alternative type-specification syntax.
       (y type: double init-keyword: y:)
       (zero-2d :: 2d-vector allocation: 'static
        init-value: (2d-vector 0))
       ;; An object initializer (constructor) method.
       ((*init* (x0 ::double) (y0 ::double))
        (set! x x0)
        (set! y y0))
       ((*init* (xy0 ::double))
        ;; Call above 2-argument constructor.
        (invoke-special 2d-vector (this) '*init* xy0 xy0))
       ;; Need a default constructor as well.
       ((*init*) #!void)
       ((add (other ::2d-vector)) ::2d-vector
        ;; Kawa compiles this using primitive Java types!
        (2d-vector
          x: (+ x other:x)
          y: (+ y other:y)))
       ((scale (factor ::double)) ::2d-vector
        (2d-vector x: (* factor x) y: (* factor y))))

     (define-simple-class 3d-vector (2d-vector)
       (z type: double init-value: 0.0 init-keyword: z:)
       ;; A constructor which calls the superclass constructor.
       ((*init* (x0 ::double) (y0 ::double) (z0 ::double))
        (invoke-special 2d-vector (this) '*init* x0 y0)
        (set! z z0))
       ;; Need a default constructor.
       ((*init*) #!void)
       ((scale (factor ::double)) ::2d-vector
        ;; Note we cannot override the return type to 3d-vector
        ;; because Kawa doesn't yet support covariant rteurn typesk.
        (3d-vector
          x: (* factor x)
          y: (* factor (this):y) ;; Alternative syntax.
          z: (* factor z))))

   Note we define both explicit non-default constructor methods, and we
associate fields with keywords, so they can be named when allocating an
object.  Using keywords requires a default constructor, and since having
non-default constructors suppresses the implicit default constructor we
have to explicitly define it.  Using both styles of constructors is
rather redundant, though.

19.1.5 Synchronized methods
---------------------------

Kawa doesn't directly support marking a method as `synchronized', but
you can get the same effect using a `synchronized' expression:

     (define-simple-class <Bar> ()
       ;; non-static method
       ((foo) :: void
        (synchronized (this)
     		 (synchronized-block)))
       ;; static method
       ((baz) allocation: 'static :: void
        (synchronized <Bar>
     		 (synchronized-block))))


File: kawa.info,  Node: Anonymous classes,  Next: Enumerations,  Prev: Defining new classes,  Up: Objects Classes and Modules

19.2 Anonymous classes
======================

 -- Syntax: object `('supers ...`)' field-or-method-decl ...
     Returns a new instance of an anonymous (inner) class.  The syntax
     is similar to `define-class'.

          field-or-method-decl `::=' field-decl | method-decl
          field-decl `::=' `('fname [[[`::'] ftype] finit]`)'
              | `('fname [`::' ftype] [option-keyword option-value]*`)'
          method-decl `::=' `(('method-name formal-arguments`)' [[`::'] rtype] body`)'

     Returns a new instance of a unique (anonymous) class.  The class
     inherits from the list of supers, where at most one of the elements
     should be the base class being extended from, and the rest are
     interfaces.

     This is roughly equivalent to:

          (begin
            (define-simple-class hname (supers ...) field-or-method-decl ...)
            (make hname))

     A field-decl is as for `define-class', except that we also allow an
     abbreviated syntax.  Each field-decl declares a public instance
     field.  If ftype is given, it specifies the type of the field.  If
     finit is given, it is an expression whose value becomes the initial
     value of the field.  The finit is evaluated at the same time as the
     `object' expression is evaluated, in a scope where all the fnames
     are visible.

     A method-decl is as for `define-class'.

19.2.1 Lambda as shorthand for anonymous class
----------------------------------------------

An anonymous class is commonly used in the Java platform where a
function language would use a lambda expression.  Examples are call-back
handlers, events handlers, and `run' methods.  In these cases Kawa lets
you use a lambda expression as a short-hand for an anonymous class.  For
example:
     (button:addActionListener
       (lambda (e) (do-something)))
   is equivalent to:
     (button:addActionListener
       (object (java.awt.event.ActionListener)
         ((actionPerformed (e ::java.awt.event.ActionEvent))::void
          (do-something))))
   This is possible when the required type is an interface or abstract
class with a Single (exactly one) Abstract Methods.  Such a class is
sometypes called a "SAM-type", and the conversion from a lambda
expression to an anonymous class is sometimes called "SAM-conversion".

   Note that Kawa can also infer the parameter and return types of a
method that overrides a method in a super-class.


File: kawa.info,  Node: Enumerations,  Next: Module classes,  Prev: Anonymous classes,  Up: Objects Classes and Modules

19.3 Enumeration types
======================

An enumeration type is a set of named atomic enumeration values that are
distinct from other values.  You define the type using `define-enum',
and you reference enumeration values using colon notation:
     (define-enum colors (red blue green))
     (define favorite-color colors:green)
   Displaying an enum just prints the enum name, but readable output
using `write' (or the `~s' `format' specifier) prepends the type name:
     (format "~a" favorite-color) ⇒ "green"
     (format "~s" favorite-color) ⇒ "colors:green"
   The static `values' method returns a Java array of the enumeration
values, in declaration order, while `ordinal' yields the index of an
enumeration value:
     (colors:values) ⇒ [red blue green]
     ((colors:values) 1) ⇒ blue
     (favorite-color:ordinal) ⇒ 2
   If you invoke the enumeration type as a function, it will map the
name (as a string) to the corresponding value.  (This uses the `valueOf'
method.)
     (colors "red") ⇒ red
     (colors "RED") ⇒ throws IllegalArgumentException
     (eq? favorite-color (colors:valueOf "green")) ⇒ #t

   Kawa enumerations are based on Java enumerations.  Thus the above is
similar to a Java5 `enum' declaration, and the type `colors' above
extends `java.lang.Enum'.

 -- Syntax: define-enum enum-type-name option-pair... `('enum-value-name
          ...`)' field-or-method-decl...
     This declares a new enumeration type enum-type-name, whose
     enumerations values are the enum-value-name list.  You can specify
     extra options and members using option-pair and
     field-or-method-decl, which are as in `define-simple-class'.  (The
     define-enum syntax is similar to a `define-simple-class' that
     extends `java.lang.Enum'.)

   (Note that R6RS has a separate Enumerations library `(rnrs enum)'.
Unfortunately, this is not compatible with standard Java enums.  R6RS
enums are simple symbols, which means you cannot distinguish two enum
values from different enumeration types if they have the same value, nor
from a vanilla symbol.  That makes them less useful.)


File: kawa.info,  Node: Module classes,  Next: Record types,  Prev: Enumerations,  Up: Objects Classes and Modules

19.4 Modules and how they are compiled to classes
=================================================

A "module" is a set of definitions that the module "exports", as well as
some "actions" (expressions evaluated for their side effect).  The
top-level forms in a Scheme source file compile a module; the source
file is the "module source".  When Kawa compiles the module source, the
result is the "module class".  Each exported definition is translated to
a public field in the module class.

   There are two kinds of module class: A "static module" is a class (or
gets compiled to a class) all of whose public fields a static, and that
does not have a public constructor.  A JVM can only have a single global
instance of a static module.  An "instance module" has a public default
constructor, and usually has at least one non-static public field.
There can be multiple instances of an instance module; each instance is
called a "module instance".  However, only a single instance of a module
can be "registered" in an environment, so in most cases there is only a
single instance of instance modules.  Registering an instance in an
environment means creating a binding mapping a magic name (derived from
the class name) to the instance.

   In fact, any Java class class that has the properties of either an
instance module or a static module, is a module, and can be loaded or
imported as such;  the class need not have written using Scheme.

19.4.1 Name visibility
----------------------

The definitions that a module exports are accessible to other modules.
These are the "public" definitions, to use Java terminology.  By
default, all the identifiers declared at the top-level of a module are
exported, except those defined using `define-private'.  However, a major
purpose of using modules is to control the set of names exported.  One
reason is to reduce the chance of accidental name conflicts between
separately developed modules.  An even more important reason is to
enforce an interface:  Client modules should only use the names that are
part of a documented interface, and should not use internal
implementation procedures (since those may change).

   If there is a `module-export' declaration in the module, then only
those names listed in a `module-export' are exported.  There can be more
than one `module-export', and they can be anywhere in the Scheme file.
As a matter of good style, I recommend a single `module-export' near the
beginning of the file.

 -- Syntax: module-export name ...
     Make the definition for each name be exported.  Note that it is an
     error if there is no definition for name in the current module, or
     if it is defined using `define-private'.

   In this module, `fact' is public and `worker' is private:
     (module-export fact)
     (define (worker x) ...)
     (define (fact x) ...)

   Alternatively, you can write:
     (define-private (worker x) ...)
     (define (fact x) ...)

19.4.2 Definitions
------------------

In addition to `define' (which can take an optional type specifier),
Kawa has some extra definition forms.

 -- Syntax: define-private name [:: type] value
 -- Syntax: define-private (name formals) body
     Same as `define', except that `name' is not exported.

 -- Syntax: define-constant name [:: type] value
     Definites name to have the given value.  The value is readonly, and
     you cannot assign to it.  (This is not fully enforced.)  If the
     definition is at module level, then the compiler will create a
     `final' field with the given name and type.  The value is evaluated
     as normal; however, if it is a compile-time constant, it defaults
     to being static.

 -- Syntax: define-variable name [init]
     If init is specified and name does not have a global variable
     binding, then init is evaluated, and name bound to the result.
     Otherwise, the value bound to name does not change.  (Note that
     init is not evaluated if name does have a global variable binding.)

     Also, declares to the compiler that name will be looked up in the
     dynamic environment. This can be useful for shutting up warnings
     from `--warn-undefined-variable'.

     This is similar to the Common Lisp `defvar' form.  However, the
     Kawa version is (currently) only allowed at module level.

   For `define-namespace' and `define-private-namespace' see *note
Namespaces::.

19.4.3 How a module becomes a class
-----------------------------------

If you want to just use a Scheme module as a module (i.e. `load' or
`require' it), you don't care how it gets translated into a module
class.  However, Kawa gives you some control over how this is done, and
you can use a Scheme module to define a class which you can use with
other Java classes.  This style of class definition is an alternative to
`define-class', which lets you define classes and instances fairly
conveniently.

   The default name of the module class is the main part of the filename
of the Scheme source file (with directories and extensions sripped off).
That can be overridden by the `-T' Kawa command-line flag.  The
package-prefix specified by the `-P' flag is prepended to give the
fully-qualified class name.

 -- Syntax: module-name <name>
     Sets the name of the generated class, overriding the default.  If
     there is no `.' in the name, the package-prefix (specified by the
     `-P' Kawa command-line flag) is prepended.

   By default, the base class of the generated module class is
unspecified; you cannot count on it being more specific than `Object'.
However, you can override it with `module-extends'.

 -- Syntax: module-extends <class>
     Specifies that the class generated from the immediately surrounding
     module should extend (be a sub-class of) the class `<class>'.

 -- Syntax: module-implements <interface> ...
     Specifies that the class generated from the immediately surrounding
     module should implement the interfaces listed.

   Note that the compiler does _not_ currently check that all the
abstract methods requires by the base class or implemented interfaces
are actually provided, and have the correct signatures.  This will
hopefully be fixed, but for now, if you are forgot a method, you will
probably get a verifier error

   For each top-level exported definition the compiler creates a
corresponding public field with a similar (mangled) name.  By default,
there is some indirection:  The value of the Scheme variable is not that
of the field itself.  Instead, the field is a `gnu.mapping.Symbol'
object, and the value Scheme variable is defined to be the value stored
in the `Symbol'.  Howewer, if you specify an explicit type, then the
field will have the specified type, instead of being a `Symbol'.  The
indirection using `Symbol' is also avoided if you use `define-constant'.

   If the Scheme definition defines a procedure (which is not
re-assigned in the module), then the compiler assumes the variable as
bound as a constant procedure.  The compiler generates one or more
methods corresponding to the body of the Scheme procedure. It also
generates a public field with the same name; the value of the field is
an instance of a subclass of `<gnu.mapping.Procedure>' which when
applied will execute the correct method (depending on the actual
arguments).  The field is used when the procedure used as a value (such
as being passed as an argument to `map'), but when the compiler is able
to do so, it will generate code to call the correct method directly.

   You can control the signature of the generated method by declaring
the parameter types and the return type of the method.  See the applet
(*note Applet compilation::) example for how this can be done.  If the
procedures has optional parameters, then the compiler will generate
multiple methods, one for each argument list length.  (In rare cases the
default expression may be such that this is not possible, in which case
an "variable argument list" method is generated instead.  This only
happens when there is a nested scope _inside_ the default expression,
which is very contrived.)  If there are `#!keyword' or `#!rest'
arguments, the compiler generate a "variable argument list" method.
This is a method whose last parameter is either an array or a `<list>',
and whose name has `$V' appended to indicate the last parameter is a
list.

   Top-leval macros (defined using either `define-syntax' or `defmacro')
create a field whose type is currently a sub-class of
`kawa.lang.Syntax';  this allows importing modules to detect that the
field is a macro and apply the macro at compile time.

 -- Syntax: module-static name ...
 -- Syntax: module-static `#t'
 -- Syntax: module-static `#f'
 -- Syntax: module-static `'init-run'
     Control whether the generated fields and methods are static.  If
     `#t'  or `'init-run' is specified, then the module will be a static
     module, _all_ definitions will be static.  If `'init-run' is
     specified, in addition the module body is evaluated in the class's
     static initializer.  (Otherwise, it is run the first time it is
     `require''d.)  Otherwise, the module is an instance module.
     However, the names that are explicitly listed will be compiled to
     static fields and methods.  If `#f' is specified, then all exported
     names will be compiled to non-static (instance) fields and methods.

     By default, if no `module-static' is specified:

       1. If there is a `module-extends' or `module-implements'
          declaration, or one of the `--applet' or `--servlet'
          caommand-line flags was specified, then `(module-static #f)'
          is implied.

       2. If one of the command-line flags `--no-module-static',
          `--module-nonstatic', `--module-static', or
          `--module-static-run' was specified, the the default `#f',
          `#f', `#t', or `'init-run', respectively.

       3. Otherwise the default is `(module-static #t)'.  (It used to be
          `(module-static #f)' in older Kawa versions.)

     Note `(module-static #t)' usually produces more efficient code, and
     is recommended if a module contains only procedure or macro
     definitions.  (This may become the default.)  However, a static
     module means that all environments in a JVM share the same
     bindings, which you may not want if you use multiple top-level
     environments.

   Unfortuntely, the Java class verifier does not allow fields to have
arbitrary names.  Therefore, the name of a field that represents a
Scheme variable is "mangled" (*note Mangling::) into an acceptable Java
name.  The implementation can recover the original name of a field `X'
as `((gnu.mapping.Named) X).getName()' because all the standard
compiler-generate field types implemented the `Named' interface.

   The top-level actions of a module will get compiled to a `run'
method.  If there is an explicit `method-extends', then the module class
will also automatically implement `java.lang.Runnable'.  (Otherwise, the
class does not implement `Runnable', since in that case the `run' method
return an `Object' rather than `void'.  This will likely change.)

19.4.4 Requiring (importing) a module
-------------------------------------

You can import a module into the current namespace with `require'.

 -- Syntax: require modulespec
     The modulespec can be either a `<classname>' or a `'featurename'.
     In either case the names exported by the specified module (class)
     are added to the current set of visible names.

     If modulespec is `<classname>' where classname is an instance
     module (it has a public default constructor), and if no module
     instance for that class has been registered in the current
     environment, then a new instance is created and registered (using a
     "magic" identifier).  If the module class either inherits from
     `gnu.expr.ModuleBody' or implements `java.lang.Runnable' then the
     corresponding `run' method is executed.  (This is done _after_ the
     instance is registered so that cycles can be handled.)  These
     actions (creating, registering, and running the module instance)
     are done both at compile time and at run time, if necessary.

     All the public fields of the module class are then incorporated in
     the current set of local visible names in the current module.  This
     is done at compile time - no new bindings are created at run-time
     (except for the magic binding used to register the module
     instance), and the imported bindings are private to the current
     module.  References to the imported bindings will be compiled as
     field references, using the module instance (except for static
     fields).

     If the modulespec is `'featurename' then the featurename is looked
     up (at compile time) in the "feature table" which yields the
     implementing `<classname>'.

 -- Syntax: provide 'featurename
     Declare that `'featurename' is available.  A following
     `cond-expand' in this scope will match featurename.

   Using `require' and `provide' with featurenames is similar to the
same-named macros in SLib, Emacs, and Common Lisp.  However, in Kawa
these are not functions, but instead they are syntax forms that are
processed at compile time.  That is why only quoted featurenames are
supported.  This is consistent with Kawa emphasis on compilation and
static binding.

   For some examples, you may want to look in the `gnu/kawa/slib'
directory.


File: kawa.info,  Node: Record types,  Next: Dynamic records,  Prev: Module classes,  Up: Objects Classes and Modules

19.5 Record types
=================

The `define-record-type' form can be used for creating new data types,
called record types. A predicate, constructor, and field accessors and
modifiers are defined for each record type.  The `define-record-type'
feature is specified by SRFI-9
(http://srfi.schemers.org/srfi-9/srfi-9.html), which is implemented by
many modern Scheme implementations.

 -- Syntax: define-record-type type-name (constructor-name field-tag
          ...) predicate-name (field-tag accessor-name [modifier-name])
          ...
     The form `define-record-type' is generative: each use creates a new
     record type that is distinct from all existing types, including
     other record types and Scheme's predefined types. Record-type
     definitions may only occur at top-level (there are two possible
     semantics for `internal' record-type definitions, generative and
     nongenerative, and no consensus as to which is better).

     An instance of `define-record-type' is equivalent to the following
     definitions:

        • The type-name is bound to a representation of the record type
          itself.

        • The constructor-name is bound to a procedure that takes as
          many arguments as there are field-tags in the
          `(constructor-name ...)' subform and returns a new type-name
          record. Fields whose tags are listed with constructor-name
          have the corresponding argument as their initial value. The
          initial values of all other fields are unspecified.

        • The predicate-name is a predicate that returns `#t' when given
          a value returned by constructor-name and `#f' for everything
          else.

        • Each accessor-name is a procedure that takes a record of type
          type-name and returns the current value of the corresponding
          field.  It is an error to pass an accessor a value which is
          not a record of the appropriate type.

        • Each modifier-name is a procedure that takes a record of type
          type-name and a value which becomes the new value of the
          corresponding field.  The result (in Kawa) is the empty value
          `#!void'.  It is an error to pass a modifier a first argument
          which is not a record of the appropriate type.

     Set!ing the value of any of these identifiers has no effect on the
     behavior of any of their original values.

   Here is an example of how you can define a record type named `pare'
with two fields `x' and `y':
     (define-record-type pare
       (kons x y)
       pare?
       (x kar set-kar!)
       (y kdr))

   The above defines `kons' to be a constructor, `kar' and `kdr' to be
accessors, `set-kar!' to be a modifier, and `pare?' to be a predicate
for `pare's.
     (pare? (kons 1 2))        ⇒ #t
     (pare? (cons 1 2))        ⇒ #f
     (kar (kons 1 2))          ⇒ 1
     (kdr (kons 1 2))          ⇒ 2
     (let ((k (kons 1 2)))
       (set-kar! k 3)
       (kar k))                ⇒ 3

   The Kawa compiler creates a new Java class with a name derived from
the type-name.  If the type-name is valid Java class name, that becomes
the name of the Java class.  If the type-name has the form `<name>' (for
example `<pare>'), then name is used, if possible, for the Java class
name.  Otherwise, the name of the Java class is derived by "mangling"
the type-name.  In any case, the package is the same as that of the
surrounding module.

   Kawa generates efficient code for the resulting functions, without
needing to use run-time reflection.


File: kawa.info,  Node: Dynamic records,  Next: Method operations,  Prev: Record types,  Up: Objects Classes and Modules

19.6 Creating New Record Types On-the-fly
=========================================

Calling the `make-record-type' procedure creates a new record data type
at run-time, without any compile-time support.  It is primarily provided
for compatibility; in most cases it is better to use the
`define-record-type' form (*note Record types::).

 -- Procedure: make-record-type type-name field-names
     Returns a "record-type descriptor", a value representing a new data
     type disjoint from all others.  The type-name argument must be a
     string, but is only used for debugging purposes (such as the
     printed representation of a record of the new type).  The
     field-names argument is a list of symbols naming the "fields" of a
     record of the new type.  It is an error if the list contains any
     duplicates.

 -- Procedure: record-constructor rtd [field-names]
     Returns a procedure for constructing new members of the type
     represented by rtd.  The returned procedure accepts exactly as many
     arguments as there are symbols in the given list, field-names;
     these are used, in order, as the initial values of those fields in
     a new record, which is returned by the constructor procedure.  The
     values of any fields not named in that list are unspecified.  The
     field-names argument defaults to the list of field names in the
     call to `make-record-type' that created the type represented by
     rtd; if the field-names argument is provided, it is an error if it
     contains any duplicates or any symbols not in the default list.

 -- Procedure: record-predicate rtd
     Returns a procedure for testing membership in the type represented
     by rtd.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 -- Procedure: record-accessor rtd field-name
     Returns a procedure for reading the value of a particular field of
     a member of the type represented by rtd.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol field-name in that record.  The symbol field-name
     must be a member of the list of field-names in the call to
     `make-record-type' that created the type represented by rtd.

 -- Procedure: record-modifier rtd field-name
     Returns a procedure for writing the value of a particular field of
     a member of the type represented by rtd.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol field-name in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol field-name must be a member of the list of
     field-names in the call to `make-record-type' that created the type
     represented by rtd.

 -- Procedure: record? obj
     Returns a true value if obj is a record of any type and a false
     value otherwise.

 -- Procedure: record-type-descriptor record
     Returns a record-type descriptor representing the type of the given
     record.  That is, for example, if the returned descriptor were
     passed to `record-predicate', the resulting predicate would return
     a true value when passed the given record.

 -- Procedure: record-type-name rtd
     Returns the type-name associated with the type represented by rtd.
     The returned value is `eqv?' to the type-name argument given in the
     call to `make-record-type' that created the type represented by
     rtd.

 -- Procedure: record-type-field-names rtd
     Returns a list of the symbols naming the fields in members of the
     type represented by rtd.  The returned value is `equal?' to the
     field-names argument given in the call to `make-record-type' that
     created the type represented by rtd.

   Records are extensions of the class `Record'.  These procedures use
the Java 1.1 reflection facility.


File: kawa.info,  Node: Method operations,  Next: Allocating objects,  Prev: Dynamic records,  Up: Objects Classes and Modules

19.7 Calling Java methods from Scheme
=====================================

You can call a Java method as if it were a Scheme procedure using
various mechanisms.

19.7.1 Using colon notation
---------------------------

The general form of the colon notation (PathExpressions.html) is this:
     container:part-name
   This evaluates to the “part” named part-name in a given container.
If the container is a class (i.e. a `java.lang.Class' or a
`gnu.bytecode.ClassType'), then the “parts” of the class are its static
methods and fields.

   The simplest case is when the class is a fully-qualified class name:
     (java.lang.Math:sqrt 9.0) ⇒ 3.0
   This is only allowed when the name is of a class that exists and is
accessible both at compile-time and run-time, and the name is not
otherwise lexically bound.

   You can also for the container use an expression that evalutes to a
type or class.  Most commonly you'd use a class identifier:
     (<java.lang.Math>:sqrt 9.0) ⇒ 3.0
   or even (though Kawa does not promise to compile this efficiently):
     (let ((math <java.lang.Math>)) math:sqrt 9.0) ⇒ 3.0

19.7.2 Using a namespace prefix
-------------------------------

You can also use `define-namespace' to define an alias for a Java class:
     (define-namespace Int32 "class:java.lang.Integer")
   In this example the name `Int32' is a "namespace alias" for the
namespace whose full name is `"class:java.lang.Integer"'.  The full name
should be the 6 characters `"class:"' followed by the fully-qualified
name of a Java class.

   Instead of a vamespace-uri you can use a variable that names a class,
usually of the form `<classname>'.  The following is equivalent to the
above:
     (define-namespace Int32 <java.lang.Integer>)
   However, there is one important difference: The `<classname>' is
first searched in the lexical scope.  It may resolve to a class defined
in the current compilation unit (perhaps defined using
`define-simple-class'), or imported from another module, or an alias
(such as from `define-alias').  Only if `<classname>' is _not_ found in
the current scope is it tried as the class name classname.

   You can name a method using a "qualified name" containing a colon.
The part of the name before the colon is a namespace alias (in this case
`Int32'), and the part of the name after the colon is the method name.
For example:
     (Int32:toHexString 255) ⇒ ff
   This invokes the static method `toHexString' in the Java class
`java.lang.Integer', passing it the argument `255', and returning the
Java String `"ff"'.  (Note this is not the same as a Scheme string!)

   The general syntax is
     (prefix:method-name arg ...)
   This invokes the method named method-name in the class corresponding
to prefix, and the args are the method arguments.

   You can use the method name `new' to construct new objects:
     (Int32:new '|255|)
   This is equivalent to the Java expression `new Integer("255")'.  You
can also write:
     (Int32:new "255")
   Kawa is smart enough to convert the Kawa string to a Java String.

19.7.3 Invoking non-static methods
----------------------------------

To invoke a non-static method you can use a special prefix `*':
     (*:toString (list 9 8 7))
   The general syntax is
     (*:method-name instance arg ...)
   This invokes the method named method-name with instance as the target
object, and the args are the method arguments.

   Alternatively, you can invoke a non-static method using an explicit
prefix:
     (prefix:method-name instance arg ...)
   Assuming that prefix is bound to class then the above is equivalent
to:
     (*:method-name (as class instance) arg ...)
   For example:
     (Int32:doubleValue (Int32:new "00255"))
   This returns the `double' value `255.0'.

   As a shorthand, you can use the name of a Java class instead of a
namespace alias:
     (java.lang.Integer:toHexString 255)
     (java.lang.Object:toString some-value)
   If Kawa sees a qualified name with a prefix that is not defined _and_
that matches the name of a known class, then Kawa will automatically
treat the prefix as a nickname for namespace uri like
`class:java.lang.Integer'.  Both conditions should be true at both
compile-time and run-time.  However, using an explicit
`define-namespace' is recommended.

   As a final shorthand you can use an identifier in handle brackets,
such as an existing type alias like `<list>'.  The following are all
equivalent:
     (<list>:list3 'a 'b 'c)
   This is equivalent to:
     (define-namespace prefix <list>
     (prefix:list3 'a 'b 'c)
   for some otherwise-unused prefix.

19.7.4 Invoking a method with the `invoke' function
---------------------------------------------------

If you prefer, you can instead use the following functions.  (There is
also an older deprecated lower-level interface (*note Low-level Method
invocation::.)

 -- Procedure: invoke-static class name args ...
     The class can be a `<java.lang.Class>', a
     `<gnu.bytecode.ClassType>', or a `<symbol>' or `<string>' that
     names a Java class.  The name can be `<symbol>' or `<string>' that
     names one or more methods in the Java class.

     Any accessible methods (static or instance) in the specified class
     (or its super-classes) that match "name" or "name$V" collectively
     form a generic procedure.  When the procedure is applied to the
     argument list, the most specific applicable method is chosen
     depending on the argument list;  that method is then called with
     the given arguments.  Iff the method is an instance method, the
     first actual argument is used as the `this' argument.  If there are
     no applicable methods (or no methods at all!), or there is no
     "best" method, `WrongType' is thrown.

     An example (derived from the Skij FAQ):

          (invoke-static <java.lang.Thread> 'sleep 100)

     The behavior of interpreted code and compiled code is not
     identical, though you should get the same result either way unless
     you have designed the classes rather strangely.  The details will
     be nailed down later, but the basic idea is that the compiler will
     "inline" the `invoke-static' call if it can pick a single "best"
     matching method.

 -- Procedure: invoke object name args ...
     The name can be `<symbol>' or `<string>' that names one or more
     methods in the Java class.

     Any accessible methods (static or instance) in the specified class
     (or its super-classes) that match "name" or "name$V" collectively
     form a generic procedure.  When the procedure is applied to the
     argument list, the most specific applicable method is chosen
     depending on the argument list;  that method is then called with
     the given arguments.  Iff the method is an instance method, the
     object is used as the `this' argument; otherwise object is
     prepended to the args list.  If there are no applicable methods (or
     no methods at all!), or there is no "best" method, `WrongType' is
     thrown.

     The behavior of interpreted code and compiled code is not
     indentical, though you should get the same result either way unless
     you have designed the classes rather strangely.  The details will
     be nailed down later, but the basic idea is that the compiler will
     "inline" the `invoke-static' call if it can pick a single "best"
     matching method.

     If the compiler cannot determine the method to call (assuming the
     method name is constant), the compiler has to generate code at
     run-time to find the correct method.  This is much slower, so the
     compiler will print a warning.  To avoid a waning, you can use a
     type declaration, or insert a cast:

          (invoke (as <java.util.Date> my-date) 'setDate cur-date)

     or

          (let ((my-date :: <java.util.Date> (calculate-date))
                (cur-date :: <int> (get-cur-date)))
            (invoke my-date 'setDate cur-date))

 -- Procedure: invoke-special class receiver-object name arg ...
     The class can be a `<java.lang.Class>', a
     `<gnu.bytecode.ClassType>', or a `<symbol>' or `<string>' that
     names a Java class.  The name can be `<symbol>' or `<string>' that
     names one or more methods in the Java class.

     This procedure is very similar to `invoke' and `invoke-static' and
     invokes the specified method, ignoring any methods in subclasses
     that might overide it.  One interesting use is to invoke a method
     in your super-class like the Java language `super' keyword.

     Any methods in the specified class that match "name" or "name$V"
     collectively form a generic procedure.  That generic procedure is
     then applied as in `invoke' using the `receiver-object' and the
     arguments (if any).

     The compiler must be able to inline this procedure (because you
     cannot force a specific method to be called using reflection).
     Therefore the class and name must resolve at compile-time to a
     specific method.

          (define-simple-class <MyClass> (<java.util.Date>)
            ((get-year) :: <int>
             (+ (invoke-special <java.util.Date> (this) 'get-year)) 1900)
            ((set-year (year :: <int>)) :: <void>
             (invoke-special <java.util.Date> (this) 'set-year (- year 1900))))

 -- Procedure: class-methods class name
     Return a generic function containing those methods of class that
     match the name name, in the sense of `invoke-static'.  Same as:

          (lambda args (apply invoke-static (cons class (cons name args))))

   Some examples using these functions are `vectors.scm' and
`characters.scm' the directory `kawa/lib' in the Kawa sources.

19.7.5 Method names
-------------------

All of the above select a method to invoke base on specified method name
and argments.  If specified name is not a Java name, it is "mangled"
(*note Mangling::) into a valid Java name.  All accessible methods whose
names match are considered.  Methods that match after appending `$V' or
`$X' or `$V$X' are also considered.  A `$V' suffix matches a variable
number of arguments:  any excess arguments are collect into an
`gnu.lists.LList' or a Java array (depending on the final parameter
type).  A `$X' specifies that the method expects an extra implicit
`CallContext' parameter.  In that case the method's result is written to
the `CallContext', so the method result type must be `void'.

   (Kawa compiles a procedure with a `#!rest' or keyword args whose name
is `fn' to a method named `fn$V'.  It adds an implicit parameter for the
extra arguments.  By default this extra extra parameter is a Scheme
list, but you can specify a Java array type instead.  In tha case the
array element type must be compatible with all the extra arguments.)

